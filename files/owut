#!/usr/bin/ucode -S
// owut - OpenWrt Upgrade Tool
// Copyright (c) 2024 Eric Fahlgren <eric.fahlgren@gmail.com>
// SPDX-License-Identifier: GPL-2.0-only
// vim: set noexpandtab softtabstop=8 shiftwidth=8 syntax=javascript:
//------------------------------------------------------------------------------

let VERSION = "%%VERSION%%";

// There's no ubus module doc yet, so dig through
// https://github.com/jow-/ucode/blob/master/lib/ubus.c#L1973

const uloop   = require("uloop");
const uclient = require("uclient");

import * as fs       from "fs";
import * as mod_ubus from "ubus";
import * as ap       from "utils.argparse";
import { cursor }    from "uci";
let uci = cursor();

const isnan = (x) => x != x;

//------------------------------------------------------------------------------

const Logger = {
	_level: 0,
	set_level: function(lvl) { this._level = lvl; },

	GREEN:  "0;255;0",
	YELLOW: "255;234;0",
	RED:    "255;0;0",

	color: function(color_name)
	{
		// TODO suppress colorization when stdout is a pipe
		return color_name == "reset" ? "\033[m" : `\033[38;2;${color_name}m`;
	},

	colorize: function(color_name, text)
	{
		return this.color(color_name) + text + this.color("reset");
	},

	_out: function(prefix, clr, fmt, ...args)
	{
		printf("%s: ", this.colorize(clr, prefix));
		printf(fmt, ...args);
	},

	err: function(fmt, ...args) { this._out("ERROR",   this.RED,    fmt, ...args); },
	wrn: function(fmt, ...args) { this._out("WARNING", this.YELLOW, fmt, ...args); },

	log: function(level, fmt, ...args)
	{
		if (this._level >= level) printf(fmt, ...args);
	},
};

let L = Logger;

function _exit(status)
{
	fs.stdout.flush();
	fs.stderr.flush();
	exit(status);
}

//------------------------------------------------------------------------------

let commands = {
	check:    { help: "Collect all resources and report stats." },
	list:     { help: "Show all the packages installed by user." },
	blob:     { help: "Display the json blob for the ASU build request." },
	download: { help: "Build, download and verify an image." },
	verify:   { help: "Verify the downloaded image." },
	install:  { help: "Install the specified local image." },
	upgrade:  { help: "Build, download, verify and install an image." },

	versions: { help: "Show available versions." },
	dump:     { help: "Collect all resources and dump internal data structures." },
	_test:    { help: null },
};

let _fstypes   = ["squashfs", "ext4", "ubifs", "jffs2"];
let _fslo      = 1;  // See https://sysupgrade.openwrt.org/ui/#model-BuildRequest
let _fshi      = 1024;
let _list_fmts = ["fs-user", "fs-all", "config"];

let arg_defs = proto([
	ap.DEFAULT_HELP,
	ap.DEFAULT_VERSION,
	{ name: "command",     position: 0, one_of: commands,      action: "store",                               help: "Sub-command to execute" },
	{ name: "version",     short: "-V", long: "--version-to",  action: "store",     nargs: 1, default: null,  help: "Specify the target version, defaults to installed version." },
	{ name: "verbosity",   short: "-v", long: "--verbose",     action: "inc",                 default: 0,     help: "Print various diagnostics.  Repeat for even more output." },
	{ name: "keep",        short: "-k", long: "--keep",        action: "set",                 default: false, help: "Save all downloaded working files." },
	{ name: "force",                    long: "--force",       action: "set",                 default: false, help: "Force download when there are no changes detected." },
	{ name: "add",         short: "-a", long: "--add",         action: "store",     nargs: 1,                 help: "Comma-separated list of new packages to add to build list." },
	{ name: "remove",      short: "-r", long: "--remove",      action: "store",     nargs: 1,                 help: "Comma-separated list of installed packages to remove from build list." },
	{ name: "init_script", short: "-I", long: "--init-script", action: "store",     nargs: 1, default: null,  help: "Path to uci-defaults script to run on first boot ('-' use stdin)." },
	{ name: "fstype",      short: "-F", long: "--fstype",      action: "enum",      nargs: 1, default: null, one_of: _fstypes, help: `Desired root file system type (${join(", ", _fstypes)}).` },
	{ name: "rootfs_size", short: "-S", long: "--rootfs-size", action: "store_int", nargs: 1, default: null, lower: _fslo, upper: _fshi, help: `Root file system size in MB (${_fslo}-${_fshi}).` },
	{ name: "image",       short: "-i", long: "--image",       action: "store",     nargs: 1, default: "/tmp/firmware.bin", help: "Image name for download, verify, install and upgrade." },
	{ name: "format",      short: "-f", long: "--format",      action: "enum",      nargs: 1, default: null, one_of: _list_fmts, help: `Format for 'list' output (${join(", ", _list_fmts)}).` },
], ap.ArgParser);

arg_defs.set_prog_info(`owut - OpenWrt Upgrade Tool version ${VERSION} (${sourcepath()})`);
arg_defs.set_bookends(
	"\nowut is an upgrade tool for OpenWrt.\n",
	"\nThank you!  Come again!\n"
);

let options = arg_defs.parse(null, {owut: "owut"});

L.set_level(options.verbosity);

//------------------------------------------------------------------------------

let ubus;
let url;      // See initialize_urls
let build;    // See collect_all for next three
let device; 
let release;


// Temporary and resource files.
// We save them all with reasonably recognizable names to aid in debugging.
let tmp_root = "/tmp/owut-";
let img_root = match(options.image, /(.*\/|)[^\.]*/)[0];
let tmp = {
	bom_json:           `${tmp_root}bom.json`,
	overview_json:      `${tmp_root}overview.json`,
	pkg_arch_json:      `${tmp_root}packages-arch.json`,
	pkg_platform_json:  `${tmp_root}packages-plat.json`,
	platform_json:      `${tmp_root}platform.json`,

	fs_conf_js:         `${tmp_root}config.js`,

	failed_html:        `${tmp_root}failures`,

	req_json:           `${tmp_root}build-request.json`,   // The POST body we send.
	build_json:         `${tmp_root}build-response.json`,  // First response.
	build_status_json:  `${tmp_root}build-status.json`,    // Overwritten subsequent responses.
	rsp_header:         `${tmp_root}rsp-header.txt`,

	firmware_sums:      `${img_root}.sha256sums`,          // Expected sha256sums from downloaded firmware.
	firmware_man:       `${img_root}-manifest.json`,       // Manifest of successful build.
};


let packageDB = {};      // Dictionary of installed packages and much status.

let packages = {  // Dictionary of package lists.
	// Collected from this device.
	installed: {}, // All the name:version pairs.
	top_level: [], // Simple list of names.

	// Collected from upgrade servers based on to-version.
	default:   [], // Another simple name list.
        available: {}, // The name:version pairs that are available for installation.
	changes:   {}, // Changes extracted from overview; structure documented in apply_pkg_mods.
};

//------------------------------------------------------------------------------

function _run(command, params)
{
	let prog = {
		command: command,
		params:  params,
	};
	return ubus.call("file", "exec", prog);
}

//------------------------------------------------------------------------------

let sha256 = {
	save: function(sum) {
		// Create the checksum file from the image name and expected sum.
		let sums = fs.open(tmp.firmware_sums, "w");
		if (sums) {
			sums.write(sprintf("%s  %s\n", sum, options.image));
			sums.close();
		}
	},

	saved_sum: function() {
		// Our saved sums is always just a single line
		let sums = fs.open(tmp.firmware_sums, "r");
		if (sums) {
			let line = split(trim(sums.read("line")), /\s+/);
			sums.close();
			if (line[1] == options.image)
				return line[0];
			L.err("invalid image '%s', but expected '%s' in sum file\n", line[1], options.image);
		}
		return null;
	},

	sum: function(file) {
		// Return the checksum for the specified file.
		let data = _run("/bin/busybox", [ "sha256sum", file ]);
		return data?.code == 0 ? substr(data.stdout, 0, 64) : null;
	},

	verify: function() {
		// Run validation against the saved checksums.
		return _run("/bin/busybox", [ "sha256sum", "-c", tmp.firmware_sums ]);
	},

};

//------------------------------------------------------------------------------

function sysupgrade(file, options)
{
	let params = options ? [...options, file] : [file];
	return _run("sysupgrade", params);
}

//------------------------------------------------------------------------------

function _request(url, dst_file, msg, json_blob)
{
	//  uclient function for simple http requests
	//   url       = self explanatory
	//   dst_file  = result of request
	//   msg       = error message if request fails
	//   json_blob = optional POST data, GET used if null

	let uc;
	let rsp_status;
	let rsp_headers;

	let output = fs.open(dst_file, "w");
	if (! output) {
		L.err("%s\nCould not write: %s\n", msg, dst_file);
		return null;
	}

	uc = uclient.new(url, null, {
		header_done: (cb) => {
			rsp_status  = uc.status();

			rsp_headers = uc.get_headers();
			rsp_headers["status"] = rsp_status.status;
			if (options.keep) {
				let hdrs = fs.open(tmp.rsp_header, "w");
				hdrs.write(sprintf("%.J\n", rsp_headers));
				hdrs.close();
			}
		},

		data_read: (cb) => {
			let data;
			while (length(data = uc.read()) > 0) {
				output.write(data);
			}
		},

		data_eof: (cb) => {
			output.close();
			uloop.end();
		},

		error: (cb, code) => {
			L.err("%s\n", code);
			uloop.end();
		},
	});

	if (! uc.ssl_init({verify: false})) {
		L.err("%s\nFailed to initialize SSL\n", msg);
		return null;
	}

	if (! uc.connect()) {
		L.err("%s\nFailed to connect\n", msg);
		return null;
	}

	let type = "GET";
	let headers = {
		"User-Agent": "owut/" + VERSION,
	};
	let args = {
		headers: headers,
	};

	if (json_blob) {
		type = "POST";
		headers["Content-Type"] = "application/json";
		args["post_data"] = json_blob;
	}

	if (! uc.request(type, args)) {
		L.err("%s\nFailed to send request\n", msg);
		return null;
	}
	uloop.run();

	L.log(1, "Downloaded %s to %s\n", url, dst_file);
	L.log(2, "Reponse headers = %.4J\n", rsp_headers);

	return rsp_status;
}

function read_tmp_file(file)
{
	// Reads 'file', then optionally deletes it.
	// Return raw text.

	let fd = fs.open(file, "r");
	let tx = fd.read("all");
	fd.close();
	if (! options.keep) {
		fs.unlink(file);
	}
	return tx;
}

function read_tmp_json(file)
{
	// Read 'file' into a json object, then optionally delete the file.
	// Primarily used to parse downloads from /tmp.

	let fd = fs.open(file, "r");
	let js = json(fd);
	fd.close();
	if (! options.keep) {
		fs.unlink(file);
	}
	return js;
}

//------------------------------------------------------------------------------
//-- Source-specific downloaders -----------------------------------------------

function dl_board()
{
	// Get the starting point for the target build.

	let msg = "Could not download platform json.";
	let rsp = _request(url.platform, tmp.platform_json, msg);
	if (rsp?.status == 200) {
		return read_tmp_json(tmp.platform_json);
	}
	return null;
}

function dl_overview()
{
	// Overview is the collection of information about the branches and their releases.
	//
	// Note that auc uses branches.json instead.  Its content is all included
	// in overview.json at '$.branches', but we like overview as it has a few
	// more useful items.  It can be found at:
	//     $url.api_root/branches.json

	let msg = `could not download '${url.overview}', aborting.`;
	let rsp = _request(url.overview, tmp.overview_json, msg);
	if (rsp?.status == 200) {
		return read_tmp_json(tmp.overview_json);
	}
	L.log(0, "Response status: %s\n", rsp?.status);
	L.err("%s\n", msg);
	_exit(1);
}

function dl_fs_conf()
{
	// Download the overview metadata from the firmware-selector, as it
	// has a much more liberal notion as to what builds are available.
	//
	// This is hacky and fragile, parsing JS into ucode, then running it.

	let msg = `could not download '${url.fs_conf}', aborting.`;
	let rsp = _request(url.fs_conf, tmp.fs_conf_js, msg);
	if (rsp?.status != 200) {
		L.log(0, "Response status: %s\n", rsp?.status);
		L.err("%s\n", msg);
		_exit(1);
	}

	let code = read_tmp_file(tmp.fs_conf_js);
	let data = loadstring(replace(code, "var config =", "return"));
	return data();
}

function dl_bom()
{
	// Download the platform BOM.

	let msg = `could not access BOM for ${build.to.version}, kernel version cannot be determined`;
	let rsp = _request(url.bom, tmp.bom_json, msg);
	if (rsp?.status == 200) {
		return read_tmp_json(tmp.bom_json);
	}
	return null;
}

function dl_failures(feed)
{
	// The build failures info is html that resides in odd, one-man-out URL
	// locations:
	//     https://downloads.openwrt.org/snapshots/faillogs/mipsel_24kc/<feed>/
	//     https://downloads.openwrt.org/releases/faillogs-23.05/mipsel_24kc/<feed>/

	let uri = feed ? `${url.failed}${feed}/` : url.failed;
	let htm = `${tmp.failed_html}-${feed ? feed : "feeds"}.html`;

	let msg = "checking build failures";
	let rsp = _request(uri, htm, msg);
	if (rsp?.status == 200) {
		return read_tmp_file(htm);
	}
	return null;
}

function dl_package_versions()
{
	// Downloads and consolidates the two sources of package versions into
	// a single object.

	let msg = "could not download package list to determine versions";
	let rsp = _request(url.pkg_arch, tmp.pkg_arch_json, msg);
	if (rsp?.status != 200) return null;
	rsp = _request(url.pkg_plat, tmp.pkg_platform_json, msg);
	if (rsp?.status != 200) return null;

	return {
		...read_tmp_json(tmp.pkg_arch_json),
		...read_tmp_json(tmp.pkg_platform_json).packages,
	};
}

function dl_build(config)
{
	if (options.keep) {
		L.log(1, "Saving build blob to %s\n", tmp.req_json);
		let save = fs.open(tmp.req_json, "w");
		if (save) {
			save.write(config);
			save.close();
		}
	}

	let msg = "failed to initiate build";
	let rsp = _request(url.build, tmp.build_json, msg, config);
	if (rsp) {
		return read_tmp_json(tmp.build_json);
	}
	return null;
}

function dl_build_status()
{
	// The response is considered valid even if status != 200, as this is the
	// ongoing status query.  See switch cases in 'download' function.

	let msg = "failed to get build status response";
	if (_request(url.build_status, tmp.build_status_json, msg)) {
		return read_tmp_json(tmp.build_status_json);
	}
	return null;
}

//------------------------------------------------------------------------------
//-- Package management --------------------------------------------------------

function is_installed(pkg)
{
	return pkg in packageDB;
}

function is_default(pkg)
{
	// Return status if package is in the defaults for this device, i.e., it
	// will be present as part of the standard install.

	// Don't attempt to do the following, because we care about things that
	// may not be installed, e.g., 'dnsmasq' replaced by 'dnsmasq-full'.
	//   return pkg in packageDB && packageDB[pkg].default;

	return pkg in packages.default;
}

function is_top_level(pkg)
{
	// We only check in the installed packages.
	return is_installed(pkg) && packageDB[pkg].top_level;
}

function is_available(pkg)
{
	// Search for a given package in the combined platform/arch package list.
	return pkg in packages.available;
}

function add_package(pkg)
{
	if (is_installed(pkg)) {
		return true;
	}
	if (! is_available(pkg)) {
		L.err("package '%s' is not available on this platform\n", pkg);
		return false;
	}

	packageDB[pkg] = {
		version:     null,
		new_version: packages.available[pkg],
		top_level:   true,
		default:     is_default(pkg),
	};
	return true;
}

function remove_package(pkg)
{
	// pkg - the package to remove, if possible.

	if (is_installed(pkg)) {
		if (! is_top_level(pkg)) {
			L.wrn("package '%s' has dependents and removal will have no effect on the build\n", pkg);
		}
		else if (is_default(pkg)) {
			L.wrn("package '%s' is a default package, removal may have unknown side effects\n", pkg);
		}
		delete packageDB[pkg];
		return true;
	}
	return false;
}

function replace_package(old_pkg, new_pkg)
{
	// Do optional replacements.  If 'old_pkg' is not installed, then we
	// have nothing to do but report success.

	if (is_installed(old_pkg)) {
		remove_package(old_pkg);
		return add_package(new_pkg);
	}
	return true;
}

//------------------------------------------------------------------------------

function collect_defaults(board, device)
{
	// Use both board json for its defaults, then add the device-specific
	// defaults to make one big defaults list.

	packages.default = ["kernel"];
	push(packages.default, ...board);
	push(packages.default, ...device);
	packages.default = sort(packages.default);
}

function apply_pkg_mods()
{
	// 1) Handle 'overview.package_changes'.
	// 2) Apply user-specified removals.
	// 3) Apply user-specified additions.
	//
	// Package names in changes are already in canonical form.
	// changes = [
	//   {
	//     source:    "name-from",  // Required string - name of package in target version
	//     target:    "name-to",    // Optional string - if present, name of replaced package in installed version
	//     revision:  123,          // Required int - revision at which package change was introduced
	//     mandatory: false,        // Optional bool - if true, then force add/remove of target/source, respectively
	//   },
	//   ...
	// ];
	//
	// For a case of simple removal, see 'kmod-nft-nat6', which was merged
	// into 'kmod-nft-nat' in rev 19160.

	let errors       = 0;
	let overview     = dl_overview();
	packages.changes = overview.branches[release.branch]?.package_changes;

	// TODO think about downgrades, i.e., when to.rev_num < from.rev_num...
	let rev_num = build.to.rev_num();
	for (let chg in packages.changes) {
		if (chg.revision <= rev_num) {
			if (chg.target) {
				if (! replace_package(chg.source, chg.target)) {
					errors++;
				}
			}
			else if (is_installed(chg.source)) {
				// No target, only source, so remove it.
				if (! remove_package(chg.source)) {
					errors++;
				}
			}
		}
	}

	// Do removals first, so any conflicts are suppressed.
	for (let pkg in split(options.remove, ",")) {
		if (! remove_package(pkg)) {
			errors++;
		}
	}
	for (let pkg in split(options.add, ",")) {
		if (! add_package(pkg)) {
			errors++;
		}
	}
	
	return errors == 0;
}

function collect_packages()
{
	// Using data from rpc-sys packagelist, build an object containing all
	// installed package data.
	//
	//     packageDB = {
	//         "pkg1": {
	//             version:     "version-string",
	//             new_version: "version-string",
	//             top_level:   bool,
	//             default:     bool,
	//         },
	//         "pkg2": {
	//             ...
	//         },
	//     };

	let installed = ubus.call("rpc-sys", "packagelist", { "all": true });
	packages.installed = sort(installed.packages);

	let top_level = ubus.call("rpc-sys", "packagelist", { "all": false });
	delete top_level.packages["kernel"]; // Not sure how they get here...
	delete top_level.packages["libc"];
	packages.top_level = sort(keys(top_level.packages));

	packages.available = dl_package_versions() ?? {};  // Might be null in ancient versions.

	for (let pkg, ver in packages.installed) {
		packageDB[pkg] = {
			version:     ver,
			new_version: packages.available[pkg],
			top_level:   pkg in packages.top_level,
			default:     is_default(pkg),
		};
	}

	if (! apply_pkg_mods()) {
		L.err("Errors collecting package data, terminating...\n");
		_exit(1);
	}

	packageDB = sort(packageDB);
}

//------------------------------------------------------------------------------

const SrcType = {
	ALL:          0,
	USER_ONLY:    1,
	DEFAULT_ONLY: 2,
};

function top_level(src_type)
{
	// Return only the installed top level packages, i.e., those upon which
	// no other package depends.  'src_type' specifies how the top-level list
	// is to be filtered.

	let tl;
	switch (src_type) {
		case SrcType.ALL:
			tl = is_top_level;
			break;

		case SrcType.DEFAULT_ONLY:
			tl = (pkg) => is_top_level(pkg) && is_default(pkg);
			break;

		case SrcType.USER_ONLY:
			tl = (pkg) => is_top_level(pkg) && ! is_default(pkg);
			break;
	}
	return filter(keys(packageDB), tl);
}

function removed_defaults()
{
	// Return the list of default packages that have been removed.
	return filter(packages.default, (p) => ! is_installed(p));
}

//------------------------------------------------------------------------------

function initialize_urls()
{
	let sysupgrade = uci.get_first("attendedsysupgrade", "server", "url") ?? "https://sysupgrade.openwrt.org";
	let fs_root    = "https://firmware-selector.openwrt.org";

	let api        = sysupgrade + "/api/v1";
	let build      = api + "/build";
	let status     = build + "/<hash>";
	let static     = sysupgrade + "/json/v1";
	let store      = sysupgrade + "/store";
	let overview   = static + "/overview.json";
	let fs_conf    = fs_root + "/config.js";

	// This should really should be in config somewhere:
	let downloads  = "https://downloads.openwrt.org";

	url = {
		sysupgrade_root: sysupgrade, // sysupgrade server base url
		api_root:        api,        // api for builds and other dynamic requests
		build:           build,      // build request
		build_status:    status,     // build status, same as build appended with hash
		static_root:     static,     // json static api root url
		store_root:      store,      // api database directory for build results
		platform:        null,       // release platform json
		overview:        overview,   // Top-level overview.json, contains available versions
		pkg_arch:        null,       // Generic arch package list, containing most of the items
		pkg_plat:        null,       // Platform packages, built specifically for this platform

		fs_root:         fs_root,    // Firmware-selector root.
		fs_conf:         fs_conf,    // FS config.js

		downloads_root:  downloads,  // download server base url
		download:        null,       // with directory at which the "to" build can be found
		bom:             null,       // BOM for target build
		failed:          null,       // Failure list html
	};
}

function version_cmp(v1, v2)
{
	// Compare two versions and return cmp value based on their relative
	// ordering.  We want to make sure RCs are before any release, and
	// SNAPSHOTs are after.

	// BUG - lexical, so x.10 < x.2, blarg...

	v1 = replace(v1, '-SNAP', '.99')+'~';  // ~ = chr(126), so late in sort order.
	v2 = replace(v2, '-SNAP', '.99')+'~';
	if (v1 < v2) return -1;
	if (v1 > v2) return  1;
	return 0;
}

function version_older(new_version, base_version)
{
	// Use version_cmp to see if new_version < base_version.  Useful to detect
	// if the user is attempting to downgrade their installation.
	//
	//  version_older('23.05.2', 'SNAPSHOT') -> true

	return version_cmp(new_version, base_version) < 0;
}

function show_versions(check_version_to)
{
	// Grab the ASU overview to get all the available versions, scan that
	// for version-to and report.

	let versions;
	if (false) {
		// Actually, let's ignore ASU server and get the metadata from
		// the firmware selector, as it keeps a much bigger and more
		// current list.
		let conf   = dl_fs_conf();
		let latest = conf.default_version;
		versions   = keys(conf.versions);
		push(versions, ...[ "22.03-SNAPSHOT", "23.05-SNAPSHOT"]);
		L.log(0, "Available 'version-to' values from %s:\n  ", url.fs_conf);
	}
	else {
		// This is more appropriate, in that it drops the still-available
		// but out-of-support versions.
		let overview = dl_overview();
		let latest   = overview.latest;
		let branches = overview.branches;

		versions = [];
		for (let branch, data in branches) {
			push(versions, ...data.versions);
		}
		L.log(0, "Available 'version-to' values from %s:\n  ", url.overview);
	}

	versions = sort(versions, version_cmp);
	L.log(0, "%s\n", join("\n  ", versions));

	if (check_version_to) {
		let version = build.to.version;
		if (version in versions)
			L.log(0, "\nYour version-to '%s' appears valid, so either:\n" +
			       "  1) This build has been removed from the server, or\n" +
			       "  2) The ASU server is having issues.\n", version);
		else
			L.log(0, "\nYour specified version-to '%s' is invalid.  " +
			       "Pick one from above.\n", version);
	}
}

//------------------------------------------------------------------------------

const BuildInfo = {
	is_snapshot: function() {
		return this.version == "SNAPSHOT";
	},

	is_rel_snapshot: function() {
		return match(this.version, /.*-SNAPSHOT/) != null;
	},

	is_downgrade_from: function(from) {
		if (version_older(this.version, from.version))
			return true;
		// Same or newer version, so check revision number.
		return this.rev_num() < from.rev_num();
	},

	rev_num: function() {
		// Extracts the revision number from the revision code:
		//     "r23630-842932a63d" -> 23630
		let m = match(this.rev_code, /r(\d*)-(.*)/);
		return m ? int(m[1]) : 0;
	},
};

function collect_device_info()
{
	let sysb = ubus.call("system", "board");

	let target   = sysb.release.target;
	let platform = sysb.board_name;
	let ver_from = sysb.release.version;
	let sutype; // Sysupgrade type: combined, combined-efi, sdcard or sysupgrade
	let fstype   = options.fstype ? options.fstype : sysb.rootfs_type;

	let ver_to;
	if (options.version)
		ver_to = options.version;
	else if (ver_from == "SNAPSHOT")
		ver_to = ver_from;
	else {
		let conf = dl_fs_conf();
		ver_to = conf.default_version;
	}

	// See also, auc.c:1657 'select_image' for changing installed fstype to requested one.
	// Wait, is there also "factory"??? See asu/build.py abt line 246
	if (match(target, /x86\//)) {  // This might be wrong, what about x86/geode - geos?
		platform = "generic";
		sutype   = "combined";
	}
	else {
		// Could be that sutype = "sdcard" for some devices, but
		// assume it is "sysupgrade", which might be wrong.  We'll
		// fix this after we get the profiles for the device, see
		// 'collect_all'.
		platform = replace(platform, /,/, "_");
		sutype   = "sysupgrade";
	}

	if (fs.access("/sys/firmware/efi")) {
		// All x86, maybe new armsr, too.
		sutype = `${sutype}-efi`;
	}

	// Fix character case of "snapshot" or "-rc" versions.
	ver_to = uc(ver_to);
	if (index(ver_to, "RC") > 0)
		ver_to = lc(ver_to);

	build = {
		from: proto({
			version:    ver_from,               // Full version name currently installed: "SNAPSHOT" or "22.03.1"
			rev_code:   sysb.release.revision,  // Kernel version that is currently running
			kver:       sysb.kernel,            // Current build on device
		}, BuildInfo),

		to: proto({
			version:    ver_to,                 // Full version name of target: "22.03.0-rc4", "23.05.2" or "SNAPSHOT"
			rev_code:   null,                   // Build number from target
			kver:       null,                   // Kernel version of target build, extracted from BOM
			fstype:     fstype,                 // Requested root FS type
			img_prefix: null,                   // Prefix of image being built
			img_file:   null,                   // Full image name to download and install
			date:       null,                   // Build date of target
		}, BuildInfo),
	};

	device = {
		arch:     null,              // "x86_64" or "mipsel_24kc"   or "aarch64_cortex-a53", contained in tmp.platform_json
		target:   target,            // "x86/64" or "ath79/generic" or "mediatek/mt7622", from board file
		platform: platform,          // "generic" (for x86) or "tplink,archer-c7-v4" or "linksys,e8450-ubi"
		fstype:   sysb.rootfs_type,  // "ext4" or "squashfs", what is actually present now
		sutype:   sutype,            // Sysupgrade type, combined, combined-efi or sysupgrade or sdcard
	};
}

function collect_all()
{
	collect_device_info();

	let rel_dir;
	let rel_branch;
	if (build.to.is_snapshot()) {
		rel_dir    = "snapshots";
		rel_branch = "SNAPSHOT";
	}
	else {
		rel_dir    = `releases/${build.to.version}`;
		rel_branch = replace(build.to.version, /\.[^.]*$/, "");
	}

	release = {
		branch: rel_branch,  // Release branch name: "SNAPSHOT" or "21.07" or "23.05"
		dir:    rel_dir,     // ASU and DL server release branch directory: "snapshots" or "release/23.05.0"
	};

	// We now know enough to finish up the first URL, which will give us the
	// keys to the rest of them.
	// ASU platform.json often updates days after downloads, so the
	// 'version_code' is wrong and build requests fail.
	let use_asu = false;
	url.platform = use_asu ?
		`${url.static_root}/${release.dir}/targets/${device.target}/${device.platform}.json` :
		`${url.downloads_root}/${rel_dir}/targets/${device.target}/profiles.json`;

	let board_json = dl_board();
	if (! board_json) {
		show_versions(true);
		_exit(1);
	}

	let prof = use_asu ? board_json : board_json.profiles[device.platform];
	let d = gmtime(board_json.source_date_epoch);

	device.arch         = board_json.arch_packages;
	build.to.date       = sprintf("%4d-%02d-%02dT%02d:%02d:%02dZ", d.year, d.mon, d.mday, d.hour, d.min, d.sec);
	build.to.rev_code   = board_json.version_code;
	build.to.img_prefix = prof.image_prefix;

	let location = build.to.is_snapshot()
		     ? "snapshots/faillogs"
		     : `releases/faillogs-${release.branch}`;
	url.failed   = `${url.downloads_root}/${location}/${device.arch}/`;

	url.pkg_arch = `${url.static_root}/${release.dir}/packages/${device.arch}-index.json`;
	url.pkg_plat = `${url.static_root}/${release.dir}/targets/${device.target}/index.json`;

	let prefix   = "openwrt-";
	let starget  = replace(device.target, /\//, "-");
	if (! build.to.is_snapshot())    prefix = `${prefix}${build.to.version}-`;
	if (build.to.is_rel_snapshot())  prefix = lc(`${prefix}${build.to.rev_code}-`);

	url.download = `${url.downloads_root}/${release.dir}/targets/${device.target}`;
	url.bom      = `${url.download}/${prefix}${starget}.bom.cdx.json`;

	let ver = "unknown";
	let bom = dl_bom();
	for (let comp in bom && bom.components) {
		if (comp.name == "kernel") {
			ver = comp.version;
			break;
		}
	}
	build.to.kver = ver;

	let valid_fstypes = uniq(sort(map(prof.images, (img) => img.filesystem)));
	if (! (build.to.fstype in valid_fstypes)) {
		L.err("file system type '%s' should be one of %s\n", build.to.fstype, valid_fstypes);
		_exit(1);
	}

	// Here is where we fix our guess for 'sutype' made above in
	// 'collect_device_info' (look for "sdcard" there).
	let valid_sutypes = uniq(sort(map(prof.images, (img) => img.type)));
	if (! (device.sutype in valid_sutypes)) {
		if (device.sutype == "sysupgrade" && "sdcard" in valid_sutypes) {
			device.sutype = "sdcard";
		}
		else {
			L.err("sysupgrade type '%s' should be one of %s\n", device.sutype, valid_sutypes);
			_exit(1);
		}
	}

	for (let img in prof.images) {
		if (img.filesystem == build.to.fstype) {
			if (img.type == device.sutype) {
				build.to.img_file = img.name;
				break;
			}
		}
	}

	collect_defaults(board_json.default_packages, prof.device_packages);
	collect_packages();
}

//------------------------------------------------------------------------------

function dump()
{
	// Send forth a json representation of all the stuff we've collected.
	L.log(0, '{\n');
	L.log(0, '"options": %.4J,\n', options);
	L.log(0, '"url": %.4J,\n', sort(url));
	L.log(0, '"tmp": %.4J,\n', sort(tmp));
	L.log(0, '"build": %.4J,\n', build);
	L.log(0, '"device": %.4J,\n', device);
	L.log(0, '"release": %.4J,\n', release);
	L.log(1, '"packages": %.4J,\n', packages);
	L.log(1, '"packageDB": %.4J,\n', packageDB);
	L.log(0, '}\n');
}

function list()
{
	let packages;
	switch (options.format) {
		case "config":
			packages = top_level(SrcType.USER_ONLY);
			let ctype = "y"; // "y" to install, "m" just build package.
			for (let pkg in packages) {
				L.log(0, "CONFIG_PACKAGE_%s=%s\n", pkg, ctype);
			}
			break;

		case "fs-all":
			packages = top_level(SrcType.ALL);
			L.log(0, "%s\n", join(" ", packages));
			break;

		case "fs-user":
		default:
			packages = top_level(SrcType.USER_ONLY);
			push(packages, ...map(removed_defaults(), (pkg) => "-"+pkg));
			L.log(0, "%s\n", join(" ", packages));
			break;
	}
}

function show_config()
{
	// Pretty-print the major configuration values.
	let downgrade = build.to.is_downgrade_from(build.from) ? L.colorize(L.RED, " DOWNGRADE") : "";
	L.log(0, 
		`Board-name     ${device.platform}\n`
		`Target         ${device.target}\n`
		`Root-FS-type   ${device.fstype}\n`
		`Sys-type       ${device.sutype}\n`
		`Package-arch   ${device.arch}\n`
		`Version-from   ${build.from.version} ${build.from.rev_code} (kernel ${build.from.kver})\n`
		`Version-to     ${build.to.version} ${build.to.rev_code} (kernel ${build.to.kver})${downgrade}\n`
		`Build-FS-type  ${build.to.fstype}\n`
		`Build-at       ${build.to.date}\n`
		`Image-prefix   ${build.to.img_prefix}\n`
		`Image-file     ${build.to.img_file}\n`
		`Image-URL      ${url.download}/${build.to.img_file}\n`
	);
	L.log(0, "Installed      %3d packages\n", length(packageDB));
	L.log(0, "Top-level      %3d packages\n", length(top_level(SrcType.ALL)));
	L.log(0, "Default        %3d packages\n", length(packages.default));
	L.log(0, "User-installed %3d packages (top-level only)\n", length(top_level(SrcType.USER_ONLY)));
	L.log(0, "\n");
}

const ver_bits = regexp('[^a-z0-9]', 'i');
function ver_cmp(old, new)
{
	let v1 = split(lc(old), ver_bits);
	let v2 = split(lc(new), ver_bits);
	for (let i, n1 in v1) {
		let n2 = v2[i];
		if (n1 != n2) {
			if (! isnan(int(n1))) n1 = int(n1);
			if (! isnan(int(n2))) n2 = int(n2);
			if (n1 < n2) return -1;
			if (n1 > n2) return  1;
		}
	}
	return 0;
}

function ver_older(v1, v2)
{
	// Is v1 and older version than v2?
	return ver_cmp(v1, v2) < 0;
}

function check_updates()
{
	// Scan the old and new package lists, return the number of changed
	// packages and the number of missing packages that would cause a
	// build failure.

	let changes = 0;
	let missing = 0;

	L.log(0, "Package version changes:\n");
	let w0 = max(...map(keys(packageDB), length));
	let w1 = max(...map(values(packageDB), (p) => length(p.version)));
	let f0 =`  %-${w0}s  %s%-${w1}s %s%s%s\n`;
	let new = '';
	for (let pkg, data in packageDB) {
		if (pkg in [ "kernel", "libc" ]) continue; // They aren't in 'available'?

		let old = data.version;
		let new = data.new_version;
		if (old == new) continue;

		changes++;
		let c1 = "";
		let c2 = "";
		if (old == null) {
			// This happens when you '--add' a new package.
			c1  = L.color(L.YELLOW);
			old = "not-installed";
		}
		if (new == null) {
			missing++;
			c2  = L.color(L.RED);
			new = "missing to-version";
		}
		else {
			c2  = L.color(ver_older(old, new) ? L.GREEN : L.YELLOW);
		}
		L.log(0, f0, pkg, c1, old, c2, new, L.color("reset"));
	}

	if (missing) {
		L.log(0, "%d packages missing in target version, %s\n", missing, L.colorize(L.RED, "DO NOT UPGRADE!"));
	}
	if (changes) {
		L.log(0, "%d packages are out-of-date.\n", changes);
	}
	else {
		L.log(0, "  All packages are up-to-date.\n");
	}
	L.log(0, "\n");

	return {
		missing: missing,
		changes: changes,
	};
}

function check_defaults()
{
	// Scan the package defaults to see if they are
	//    1) missing from the installation or
	//    2) modified/replaced by some other package.

	let changes = {};
	for (let pkg in packages.default) {
		// Without 'what_provides' from the package manager, we can no
		// longer tell what is replaced-by...
		if (! is_installed(pkg)) {
			changes[pkg] = L.colorize(L.YELLOW, "not installed, possibly replaced by another package");
		}
	}

	L.log(0, "Default package analysis:\n");
	if (length(changes) == 0) {
		L.log(0, "  No missing or modified default packages.\n\n");
	}
	else {
		let wid = max(...map(keys(changes), (f) => length(f)));
		let fmt = `  %-${wid}s   %s\n`;
		L.log(0, fmt, "Default", "Provided-by");
		for (let p, a in changes) {
			L.log(0, fmt, p, a);
		}
		L.log(0, "\n");
	}
}

function check_pkg_builds()
{
	// Scraping the failures.html is a total hack.
	// Let me know if you have an API on downloads (or other build site)
	// that can give this info.
	//
	// The lines we're scraping look like:
	//    <tr><td class="n"><a href="gummiboot/">gummiboot</a>/</td><td class="s">-</td><td class="d">Tue Apr 23 07:05:36 2024</td></tr>

	let failed = false;

	let html_blob = dl_failures();
	if (! html_blob) {
		L.log(0, "No package build failures found for %s %s.\n\n", build.to.version, device.arch);
	}
	else {
		L.log(0, "There are currently package build failures for %s %s:\n", build.to.version, device.arch);

		let info = regexp(
			'<td class="n"><a href="[^<]*">([^<]*)</a>/</td>' +
			'<td class="s">[^<]*</td>' +
			'<td class="d">([^<]*)</td>',
			'g'
		);

		let feeds = map(match(html_blob, info), (f) => f[1]);
		for (let feed in feeds) {
			L.log(0, "  Feed: %s\n", feed);
			html_blob = dl_failures(feed);
			if (html_blob) {
				let fails = match(html_blob, info);
				let w0    = max(...map(fails, (f) => max(25, length(f[1])) ));
				let fmt   = `    %-${w0}s  %s - %s\n`;

				for (let fail in fails) {
					let pkg  = fail[1];
					let date = fail[2];
					let msg;
					if (is_installed(pkg)) {
						failed = true;
						msg = L.colorize(L.RED, "Package installed locally, DO NOT UPGRADE!");
					}
					else {
						msg = "Package not installed locally";
					}
					L.log(0, fmt, pkg, date, msg);
				}
			}
		}

		let prefix = failed ?
			L.colorize(L.RED,   "NOTE THE ERRORS ABOVE:") :
			L.colorize(L.GREEN, "Failures don't affect this device,");
		L.log(0, "%s details at\n  %s\n\n", prefix, url.failed);
	}

	return ! failed;
}

function tests()
{
	let all = top_level(SrcType.ALL);
	let def = top_level(SrcType.DEFAULT_ONLY);
	let usr = top_level(SrcType.USER_ONLY);

	printf('defaults               %d\n  %s\n', length(packages.default), join(" ", packages.default));
	printf('all          top-level %d\n  %s\n', length(all), join(" ", all));
	printf('default-only top-level %d\n  %s\n', length(def), join(" ", def));
	printf('non-default  top-level %d\n  %s\n', length(usr), join(" ", usr));

print('xxxxxxxxxxxxxxxx def vs def\n');
let i = 0;
for (let pkg in packageDB) {
	let in_def = pkg in packages.default;
	let in_top = pkg in def;
	if (in_def || in_top) {
		i++;
		printf('  %3d %-20s  %-3s  %s\n', i, pkg, in_def ? "def" : "-", in_top ? "top" : "-");
	}
}

	if (true) {
		// Test a handful of packages;
		for (let pkg in [
			"iptables", "libncurses6", "libncursesw", "libncurses", "libncursesw6",
			"dropbear", "vim", "vim-full", "dnsmasq", "dnsmasq-full",
			"wget", "wget-ssl", "uclient-fetch",
			"bort",
		]) {
			printf("%s\n", pkg);
			print('  is_default    ', is_default(pkg), '\n');
			print('  is_installed  ', is_installed(pkg), '\n');
		}
	}
}

function blob(report)
{
	// Exclude default packages unless explicitly listed in 'packages'.  When
	// moving between releases, default packages may be added, deleted or
	// renamed, which can result in bricks if something important is missed.
	//
	// On the other hand, what if we replace a default package, say,
	// 'dnsmasq' with 'dnsmasq-full'?  Then we must use the full top-level
	// list, plus target version defaults, and set this value 'true'.
	//
	// False is the safer option, so that's our default value.
	let contains_defaults = true;

	let log_level = report ? 0 : 1;

	let build_list = top_level(SrcType.ALL); // should be '! contains_defaults' - but not really...

	let init_script;
	if (options.init_script) {
		let inits_maxlen = 20480;  // See https://sysupgrade.openwrt.org/ui/#model-BuildRequest
		let inits_file   = options.init_script == "-" ? fs.stdin : fs.open(options.init_script);
		if (! inits_file) {
			L.err("init script file '%s' does not exist\n", options.init_script);
			return null;
		}
		else {
			init_script = inits_file.read("all");
			inits_file.close();
			if (length(init_script) > inits_maxlen) {
				L.err("'%s' is over the %s byte maximum\n", options.init_script, inits_maxlen);
				return null;
			}
		}
	}

	if (build.to.fstype != device.fstype) {
		L.log(log_level, "Build: Change file system type from '%s' to '%s'\n", device.fstype, build.to.fstype);
	}

	let blob = {
		client:        "owut/" + VERSION,
		target:        device.target,
		profile:       device.platform,  // sanitized board name

		version:       build.to.version,
		version_code:  build.to.rev_code,
		filesystem:    build.to.fstype,

		diff_packages: contains_defaults,
		packages:      build_list,
	};

	if (options.rootfs_size) {
		blob.rootfs_size_mb = options.rootfs_size;
		L.log(log_level, "Build: ROOTFS_PARTSIZE set to %d MB\n", options.rootfs_size);
	}

	if (init_script) {
		blob.defaults = init_script;
		L.log(log_level, "Build: Included init script '%s' (%d bytes) in build request\n", options.init_script, length(init_script));
	}

	return blob;
}

function json_blob()
{
	let b = blob(true);
	return b ? sprintf("%J", b) : null;
}

function show_blob()
{
	let b = blob();
	if (b) {
		L.log(0, "%.4J\n", b);
	}
}

function select_image(images)
{
	for (let image in images) {
		if (image.filesystem == build.to.fstype && image.type == device.sutype) {
			return image;
		}
	}
	return null;
}

function verify_image()
{
	// Verify the image with both the saved sha256sum and by passing it
	// to 'sysupgrade --test'.
	//
	// Failed images will be delete, unless '--keep' is set.

	let image = options.image;

	if (! fs.access(image)) {
		L.err("image file '%s' does not exist\n", image);
		return false;
	}

	let info = fs.stat(image);
	L.log(0, "Verifying   : %s (%d bytes) against %s\n", image, info.size, tmp.firmware_sums);

	let result = sha256.verify();
	if (result?.code == 0) {
		L.log(0, "  Saved sha256 matches\n");
	}
	else {
		let file_sha = sha256.sum(image);
		let expected = sha256.saved_sum();
		L.err(`sha256 doesn't match:\n`
		    `    calculated '${file_sha}'\n`
		    `    saved      '${expected}'\n`);
		if (! options.keep) {
			fs.unlink(image);
		}
		return false;
	}

	result = sysupgrade(image, ["--test"]);
	if (result?.code == 0) {
		L.log(0, "  %s\n", join("\n  ", split(trim(result.stderr), "\n")));
	}
	else {
		L.err("sysupgrade validation failed:\n");
		if (result.stdout) L.log(0, "stdout =\n%s\n", result.stdout);
		if (result.stderr) L.log(0, "stderr =\n%s\n", result.stderr);
		if (! options.keep) {
			fs.unlink(image);
		}
		return false;
	}

	L.log(0, "Checks complete, image is valid.\n");
	return true;
}

function download()
{
	// Use the json_blob to create a build request, run the request and
	// download the result.
	//
	// On success, return true, otherwise spew all sorts of stuff and
	// return false.
	//
	// To download the built image:
	// https://github.com/openwrt/luci/blob/master/applications/luci-app-attendedsysupgrade/htdocs/luci-static/resources/view/attendedsysupgrade/overview.js#L108

	let blob = json_blob();
	if (! blob) return false;

	let start    = time();
	let response = dl_build(blob);
	L.log(0, "\nRequesting build ----------------------\n");

	let hash = response?.request_hash;
	if (hash) {
		L.log(0, "Hash:   %s\n", hash);
		url.build_status = `${url.build}/${hash}`;
	}

	let queries = 0;
	while (response) {
		let status = response.status;

		L.log(0, "Status: %d\n", status);
		L.log(0, "Detail: %s", substr(response.detail, 0, 6) == "Error:" ? L.colorize(L.RED, response.detail) : response.detail);
		switch (response.detail) {
			case "queued":
				L.log(0, " - %d ahead of you", response.queue_position);
				break;
			case "started":
				L.log(0, " - %s", response.imagebuilder_status ?? "setup");
				break;
			default:
				break;
		}
		L.log(0, "\n");

		switch (status) {
			case 202: // Build in-progress, check in after 10 seconds.
				sleep(10000);
				queries++;
				L.log(0, "\nProgress %3d (%4ds) -----------------------------\n", queries, time()-start);
				response = dl_build_status();
				break;

			case 200: // All done.
				L.log(0, "\nBuild completed in %d seconds.\n", time()-start);
				L.log(1, "  build_at       = %s\n", response.build_at);
				L.log(1, "  version_number = %s\n", response.version_number);
				L.log(1, "  version_code   = %s\n", response.version_code);
				L.log(0, "  rootfs_size_mb = %s\n", response.request.rootfs_size_mb || "default");
				L.log(0, "  init-script    = %s\n", response.request.defaults ? options.init_script : "no-init-script");
				L.log(2, "  images = %.4J\n",       response.images);
				L.log(3, "  build_cmd = %.4J\n",    response.build_cmd);
				L.log(3, "  manifest = %.4J\n",     response.manifest);
				L.log(0, "\n");

				let image = select_image(response.images);
				if (! image) {
					L.err("Could not locate an image for '%s' and '%s'...\n", build.to.fstype, device.sutype);
					return false;
				}

				let sha = image.sha256;  // LuCI-ASU uses sha256_unsigned for something...
				let dir = response.bin_dir;
				let bin = `${url.store_root}/${dir}`;
				let img = `${bin}/${image.name}`;
				let dst = options.image;

				L.log(0, "Image source: %s\n", img);
				L.log(0, "Image saved : %s\n", dst);

				let msg = `couldn't download image ${image.name}`;
				let rsp = _request(img, dst, msg);
				if (rsp?.status != 200) {
					// need more output here, if 404 or whatever
					return false;
				}

				let manifest = fs.open(tmp.firmware_man, "w");
				if (manifest) {
					manifest.write(sprintf("%.4J\n", response.manifest));
					manifest.close();
					L.log(0, "Manifest    : %s\n", tmp.firmware_man);
				}

				sha256.save(sha);

				return verify_image();

			// Everything else is "failure - we're done" cases.
			case 400: // Invalid build request.
			case 422: // Unknown package.
			case 500: // Invalid build request.
			default:  // ???
				if (response.error ) L.log(0, "error  =\n%s\n", response.error);
				if (response.stdout) L.log(0, "stdout =\n%s\n", response.stdout);
				if (response.stderr) L.log(0, "stderr =\n%s\n", response.stderr);
				L.err("build failed with status %s\n", status);
				return false;
		}
	}
	return false;
}

function install()
{
	// Run sysupgrade to install the image.
	// Probably need some more options reflected from sysupgrade itself.
	// '-n' = discard config comes to mind first, maybe '-f' = force, too.

	sysupgrade(options.image);
}

//------------------------------------------------------------------------------

if (options.verbosity) {
	arg_defs.show_version();
}

ubus = mod_ubus.connect();
if (! ubus) {
	die(`Unable to connect to ubus: ${mod_ubus.error()}\n`);
}

if (! uloop.init()) {
	die(`Unable to initialize uloop: ${uloop.error()}\n`);
}

initialize_urls();

switch (options.command) {
	case "versions":
		show_versions(false);
		break;

	case "dump":
		collect_all();
		dump();
		break;

	case "list":
		collect_all();
		list();
		break;

	case "check":
		collect_all();
		show_config();
		check_updates();
		check_defaults();
		check_pkg_builds();
		break;

	case "blob":
		collect_all();
		show_blob();
		break;

	case "download":
	case "upgrade":
		collect_all();
		show_config();
		let updates = check_updates();
		if (updates.missing) {
			L.err("update checks reveal errors, can't proceed\n");
			break;
		}
		check_defaults();
		if (! check_pkg_builds()) {
			L.err("package build checks reveal errors, can't proceed\n");
			break;
		}
		if (updates.changes == 0) {
			if (options.force)
				L.wrn("Forcing build with no changes.\n");
			else {
				L.log(0, "There are no changes to %s (see '--force').\n", options.command);
				break;
			}
		}
		if (download() && options.command == "upgrade") {
			install();
		}
		break;
	
	case "install":
		if (verify_image()) {
			install();
		}
		break;

	case "verify":
		verify_image();
		break;

	case "_test":
		collect_all();
		show_config();
		check_updates();
		check_defaults();
		check_pkg_builds();
		tests();
		break;

	default:
		L.err("'%s' not implemented yet.\n", options.command);
		break;
}

uloop.done();
ubus.disconnect();
_exit();
