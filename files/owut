#!/usr/bin/ucode -S
// owut - OpenWrt Upgrade Tool
// Copyright (c) 2024 Eric Fahlgren <eric.fahlgren@gmail.com>
// SPDX-License-Identifier: GPL-2.0-only
// vim: set noexpandtab softtabstop=8 shiftwidth=8 syntax=javascript:
//------------------------------------------------------------------------------
// TODO
// Makefile
// See
//    openwrt/openwrt/package/network/config/firewall4/Makefile
//    openwrt/packages/utils/auc/Makefile
// When you create a Makefile, this version depends on
//    'ucode'
//    'ucode-mod-fs'
//    'ucode-mod-ubus'
//    'ucode-mod-uci'
//    'ucode-mod-uclient'
//    'ucode-mod-uloop'
//    'busybox sha256sum' for checksum calculation
//    'sysupgrade' for all that stuff
//
// dig through auc ssl_ctx setup and fix uc.ssl_init
// finish up options to
//   include new - still needs to do closure on dependencies
//   exclude old - needs major rework...
//
// look at 'Default package analysis' in pkg_scan...
//------------------------------------------------------------------------------

let VERSION = "%%VERSION%%";  // Modified at packaging time by build script, see Makefile.
if (VERSION == "%%VER"+"SION%%") VERSION = "24.0.0";

// There's no ubus module doc yet, so dig through
// https://github.com/jow-/ucode/blob/master/lib/ubus.c#L1973

const uloop   = require("uloop");
const uclient = require("uclient");

import * as fs       from "fs";
import * as mod_ubus from "ubus";
import * as ap       from "utils.argparse";
import { isnan  }    from "math";
import { cursor }    from "uci";
let uci = cursor();

const Color = {
	GREEN:  "0;255;0",
	YELLOW: "255;234;0",
	RED:    "255;0;0",
};

function color(color)
{
	if (color == "reset")
		return `\033[m`;
	return `\033[38;2;${color}m`;
}

function colorize(text, color_name)
{
	return color(color_name) + text + color("reset");
}

function _exit(status)
{
	fs.stdout.flush();
	fs.stderr.flush();
	exit(status);
}

//------------------------------------------------------------------------------

let commands = {
	check:    { help: "Collect all resources and report stats." },
	list:     { help: "Show all the packages installed by user." },
	blob:     { help: "Display the json blob for the ASU build request." },
	download: { help: "Build, download and verify an image." },
	verify:   { help: "Verify the downloaded image." },
	install:  { help: "Install the specified local image." },
	upgrade:  { help: "Build, download, verify and install an image." },

	versions: { help: "Show available versions." },
	dump:     { help: "Collect all resources and dump internal data structures." },
	_test:    { help: null },
};

let _fstypes   = ["squashfs", "ext4", "ubifs", "jffs2"];
let _fslo      = 1;  // See https://sysupgrade.openwrt.org/ui/#model-BuildRequest
let _fshi      = 1024;
let _list_fmts = ["fs-user", "fs-all", "config"];

let arg_defs = proto([
	ap.DEFAULT_HELP,
	ap.DEFAULT_VERSION,
	{ name: "command",     position: 0, one_of: commands,      action: "store",                               help: "Sub-command to execute" },
	{ name: "version",     short: "-V", long: "--version-to",  action: "store",     nargs: 1, default: null,  help: "Specify the target version, defaults to installed version." },
	{ name: "keep",        short: "-k", long: "--keep",        action: "set",                 default: false, help: "Save all downloaded working files." },
	{ name: "verbosity",   short: "-v", long: "--verbose",     action: "inc",                 default: 0,     help: "Print various diagnostics.  Repeat for even more output." },
	{ name: "add",         short: "-a", long: "--add",         action: "store",     nargs: 1,                 help: "Comma-separated list of new packages to add to build list." },
	{ name: "remove",      short: "-r", long: "--remove",      action: "store",     nargs: 1,                 help: "Comma-separated list of installed packages to remove from build list." },
	{ name: "init_script", short: "-I", long: "--init-script", action: "store",     nargs: 1, default: null,  help: "Path to uci-defaults script to run on first boot ('-' use stdin)." },
	{ name: "fstype",      short: "-F", long: "--fstype",      action: "enum",      nargs: 1, default: null, one_of: _fstypes, help: `Desired root file system type (${join(", ", _fstypes)}).` },
	{ name: "rootfs_size", short: "-S", long: "--rootfs-size", action: "store_int", nargs: 1, default: null, lower: _fslo, upper: _fshi, help: `Root file system size in MB (${_fslo}-${_fshi}).` },
	{ name: "image",       short: "-i", long: "--image",       action: "store",     nargs: 1, default: "/tmp/firmware.bin", help: "Image name for download, verify, install and upgrade." },
	{ name: "format",      short: "-f", long: "--format",      action: "enum",      nargs: 1, default: null, one_of: _list_fmts, help: `Format for 'list' output (${join(", ", _list_fmts)}).` },
], ap.ArgParser);

arg_defs.set_prog_info(`owut - OpenWrt Upgrade Tool version ${VERSION} (${sourcepath()})`);
arg_defs.set_bookends(
	"\nowut is an upgrade tool for OpenWrt.\n",
	"\nThank you!  Come again!\n"
);

let options = arg_defs.parse(null, {owut: "owut"});

//------------------------------------------------------------------------------

function log(verbosity, msg)
{
	if (options.verbosity >= verbosity) {
		print(msg);
	}
}

//------------------------------------------------------------------------------

let ubus;
let url;      // See initialize_urls
let build;    // See collect_all for next three
let device; 
let release;
let package_changes; // See apply_pkg_mods


// Temporary and resource files.
// We save them all with reasonably recognizable names to aid in debugging.
let tmp_root = "/tmp/owut-";
let img_root = match(options.image, /(.*\/|)[^\.]*/)[0];
let tmp = {
	bom_json:           `${tmp_root}bom.json`,
	overview_json:      `${tmp_root}overview.json`,
	pkg_arch_json:      `${tmp_root}packages-arch.json`,
	pkg_platform_json:  `${tmp_root}packages-plat.json`,
	platform_json:      `${tmp_root}platform.json`,

	fs_conf_js:         `${tmp_root}config.js`,

	failed_html:        `${tmp_root}failures.html`,

	req_json:           `${tmp_root}build-request.json`,   // The POST body we send.
	build_json:         `${tmp_root}build-response.json`,  // First response.
	build_status_json:  `${tmp_root}build-status.json`,    // Overwritten subsequent responses.
	rsp_header:         `${tmp_root}rsp-header.txt`,

	firmware_sums:      `${img_root}.sha256sums`,          // Expected sha256sums from downloaded firmware.
	firmware_man:       `${img_root}-manifest.json`,       // Manifest of successful build.
};


let packageDB = {};  // Dictionary mirroring opkg data.
let packageList;     // Dictionary of package name and version that are available for installation.

let packages = {  // Dictionary of package lists.
	installed: [],
	default:   [],
};

//------------------------------------------------------------------------------

function _run(command, params)
{
	let prog = {
		command: command,
		params:  params,
	};
	return ubus.call("file", "exec", prog);
}

//------------------------------------------------------------------------------

let sha256 = {
	save: function(sum) {
		// Create the checksum file from the image name and expected sum.
		let sums = fs.open(tmp.firmware_sums, "w");
		if (sums) {
			sums.write(sprintf("%s  %s\n", sum, options.image));
			sums.close();
		}
	},

	saved_sum: function() {
		// Our saved sums is always just a single line
		let sums = fs.open(tmp.firmware_sums, "r");
		if (sums) {
			let line = split(trim(sums.read("line")), /\s+/);
			sums.close();
			if (line[1] == options.image)
				return line[0];
			warn(`ERROR: invalid image '${line[1]}', but expected '${options.image}' in sum file\n`);
		}
		return null;
	},

	sum: function(file) {
		// Return the checksum for the specified file.
		let data = _run("/bin/busybox", [ "sha256sum", file ]);
		return data?.code == 0 ? substr(data.stdout, 0, 64) : null;
	},

	verify: function() {
		// Run validation against the saved checksums.
		return _run("/bin/busybox", [ "sha256sum", "-c", tmp.firmware_sums ]);
	},

};

//------------------------------------------------------------------------------

function sysupgrade(file, options)
{
	let params = options ? [...options, file] : [file];
	return _run("sysupgrade", params);
}

//------------------------------------------------------------------------------

function _request(url, dst_file, msg, json_blob)
{
	//  uclient function for simple http requests
	//   url       = self explanatory
	//   dst_file  = result of request
	//   msg       = error message if request fails
	//   json_blob = optional POST data, GET used if null

	let uc;
	let rsp_status;
	let rsp_headers;

	let output = fs.open(dst_file, "w");
	if (! output) {
		warn(`${msg}\nCould not write: ${dst_file}\n`);
		return null;
	}

	uc = uclient.new(url, null, {
		header_done: (cb) => {
			rsp_status  = uc.status();

			rsp_headers = uc.get_headers();
			rsp_headers["status"] = rsp_status.status;
			if (options.keep) {
				let hdrs = fs.open(tmp.rsp_header, "w");
				hdrs.write(sprintf("%.J\n", rsp_headers));
				hdrs.close();
			}
		},

		data_read: (cb) => {
			let data;
			while (length(data = uc.read()) > 0) {
				output.write(data);
			}
		},

		data_eof: (cb) => {
			output.close();
			uloop.end();
		},

		error: (cb, code) => {
			warn(`ERROR: ${code}\n`);
			uloop.end();
		},
	});

	if (! uc.ssl_init({verify: false})) {
		warn(`${msg}\nFailed to initialize SSL\n`);
		return null;
	}

	if (! uc.connect()) {
		warn(`${msg}\nFailed to connect\n`);
		return null;
	}

	let type = "GET";
	let headers = {
		"User-Agent": "owut/" + VERSION,
	};
	let args = {
		headers: headers,
	};

	if (json_blob) {
		type = "POST";
		headers["Content-Type"] = "application/json";
		args["post_data"] = json_blob;
	}

	if (! uc.request(type, args)) {
		warn(`${msg}\nFailed to send request\n`);
		return null;
	}
	uloop.run();

	if (options.verbosity > 0) {
		printf("Downloaded %s to %s\n", url, dst_file);
	}
	if (options.verbosity > 1) {
		printf("Reponse headers = %.4J\n", rsp_headers);
	}

	return rsp_status;
}

function read_tmp_file(file)
{
	// Reads 'file', then optionally deletes it.
	// Return raw text.

	let fd = fs.open(file, "r");
	let tx = fd.read("all");
	fd.close();
	if (! options.keep) {
		fs.unlink(file);
	}
	return tx;
}
function read_tmp_json(file)
{
	// Read 'file' into a json object, then optionally delete the file.
	// Primarily used to parse downloads from /tmp.

	let fd = fs.open(file, "r");
	let js = json(fd);
	fd.close();
	if (! options.keep) {
		fs.unlink(file);
	}
	return js;
}

//------------------------------------------------------------------------------
//-- Source-specific downloaders -----------------------------------------------

function dl_board()
{
	// Get the starting point for the target build.

	let msg = "ERROR: Could not download platform json.";
	let rsp = _request(url.platform, tmp.platform_json, msg);
	if (rsp?.status == 200) {
		return read_tmp_json(tmp.platform_json);
	}
	return null;
}

function dl_overview()
{
	// Overview is the collection of information about the branches and their releases.
	//
	// Note that auc uses branches.json instead.  Its content is all included
	// in overview.json at '$.branches', but we like overview as it has a few
	// more useful items.  It can be found at:
	//     $url.api_root/branches.json

	let msg = `FATAL ERROR: could not download '${url.overview}', aborting.`;
	let rsp = _request(url.overview, tmp.overview_json, msg);
	if (rsp?.status == 200) {
		return read_tmp_json(tmp.overview_json);
	}
	warn(`Response status: ${rsp?.status}\n`);
	warn(msg+"\n");
	_exit(1);
}

function dl_fs_conf()
{
	// Download the overview metadata from the firmware-selector, as it
	// has a much more liberal notion as to what builds are available.
	//
	// This is hacky and fragile, parsing JS into ucode, then running it.

	let msg = `FATAL ERROR: could not download '${url.fs_conf}', aborting.`;
	let rsp = _request(url.fs_conf, tmp.fs_conf_js, msg);
	if (rsp?.status != 200) {
		warn(`Response status: ${rsp?.status}\n`);
		warn(msg+"\n");
		_exit(1);
	}

	let code = read_tmp_file(tmp.fs_conf_js);
	let data = loadstring(replace(code, "var config =", "return"));
	return data();
}

function dl_bom()
{
	// Download the platform BOM.

	let msg = `ERROR: Could not access BOM for ${build.to.version}, kernel version cannot be determined`;
	let rsp = _request(url.bom, tmp.bom_json, msg);
	if (rsp?.status == 200) {
		return read_tmp_json(tmp.bom_json);
	}
	return null;
}

function dl_failures()
{
	// The build failures info is html that resides in odd, one-man-out URL
	// locations:
	//     https://downloads.openwrt.org/snapshots/faillogs/mipsel_24kc/packages/
	//     https://downloads.openwrt.org/releases/faillogs-23.05/mipsel_24kc/packages/

	let msg = `No package build failures found for ${build.to.version} ${device.arch}`;
	let rsp = _request(url.failed, tmp.failed_html, msg);
	if (rsp?.status == 200) {
		return read_tmp_file(tmp.failed_html);
	}
	return null;
}

function dl_package_versions()
{
	// Downloads and consolidates the two sources of package versions into
	// a single object.

	let msg = `ERROR: Could not download package list to determine versions`;
	let rsp = _request(url.pkg_arch, tmp.pkg_arch_json, msg);
	if (rsp?.status != 200) return null;
	rsp = _request(url.pkg_plat, tmp.pkg_platform_json, msg);
	if (rsp?.status != 200) return null;

	return {
		...read_tmp_json(tmp.pkg_arch_json),
		...read_tmp_json(tmp.pkg_platform_json).packages,
	};
}

function dl_build(config)
{
	if (options.keep) {
		if (options.verbosity > 0) {
			printf("Saving build blob to %s\n", tmp.req_json);
		}
		let save = fs.open(tmp.req_json, "w");
		if (save) {
			save.write(config);
			save.close();
		}
	}

	let msg = `ERROR: Failed to initiate build`;
	let rsp = _request(url.build, tmp.build_json, msg, config);
	if (rsp) {
		return read_tmp_json(tmp.build_json);
	}
	return null;
}

function dl_build_status()
{
	// The response is considered valid even if status != 200, as this is the
	// ongoing status query.  See switch cases in 'download' function.

	let msg = `ERROR: Failed to get build status response`;
	if (_request(url.build_status, tmp.build_status_json, msg)) {
		return read_tmp_json(tmp.build_status_json);
	}
	return null;
}

//------------------------------------------------------------------------------
//-- Package management --------------------------------------------------------

function canonical_name(pkg)
{
	// Scan the package database for a matching ABI-versioned name, and if
	// it exists, return the unversioned name for the package.
	for (let pkg_name, data in packageDB) {
		if (pkg == data?.versioned) {
			return pkg_name;
		}
	}
	return pkg;
}

function what_provides(pkg, return_self)
{
	// If a package doesn't appear directly in the installed packages, look
	// and see if the abstract package name is aliased to an actual package.
	// vim -> vim-full  or  tc -> tc-tiny

	// ??? can this possibly return more than one value (like 'provides_what'
	// does)?  I don't think it can, unless the package  database is screwed
	// up somehow.
	// Oho, see 'wget' - provided by both 'uclient-fetch' and 'wget-ssl'

	for (let pkg_name, data in packageDB) {
		if (pkg in data.provides) {
			return pkg_name;
		}
		if (pkg == data?.versioned) {
			// In case we're provided an ABI-versioned one.
			return pkg_name;
		}
	}
	return return_self ? pkg : null;
}

function provides_what(pkg)
{
	// Inverse of above.  Given a versioned or variant package, find out what
	// its base package is named.
	// vim-full -> vim  or  libjson-script202312041 -> libjson-script

	return packageDB[pkg]?.provides;
}

function depends_what(pkg)
{
	// Given a package, return the list of packages it depends upon, i.e., those
	// packages that will be installed implicitly by 'opkg' dependency checking.

	return packageDB[pkg]?.depends;
}

function what_depends(pkg)
{
	// Given a package, return the list of packages that depend on it.  If the
	// result is empty, this is a top-level package that must be explicitly
	// installed.
	//
	// We must use all of the aliases for a package, as the various package
	// 'depends' will contain non-specific names: 'tc' might be from
	// 'tc-tiny', or 'iptables' from 'iptables-nft'.

	pkg = what_provides(pkg, true);
	let aliases = [ pkg ];
	if (packageDB[pkg]?.versioned) {
		push(aliases, packageDB[pkg].versioned);
	}
	let alternates = provides_what(pkg);
	if (alternates) {
		push(aliases, ...alternates);
	}

	let result = [];
	for (let alias in aliases) {
		for (let pkg_name, data in packageDB) {
			if (alias in data.depends) {
				push(result, pkg_name);
			}
		}
	}
	return length(result) ? result : null;
}

function is_default(pkg)
{
	// Return status if package is in the defaults for this device, i.e., it
	// will be present as part of the standard install.

	return pkg in packages.default;
}

function is_installed(pkg)
{
	// Return status if package is installed on this device.
	//
	// Do not look in what-provides to see if we should translate there.
	// That causes issues for things like dnsmasq-full which provides dnsmasq,
	// so a call to is_installed('dnsmasq') says yes, when it should say no.
	//
	// Maybe add an 'is_provided' for those who need it, distinct from the
	// actual package installed that provides it.

	pkg = canonical_name(pkg);
	return pkg in packageDB;
}

function is_essential(pkg)
{
	// Marked as "essential" in the package manager's database, so never delete it.
	pkg = canonical_name(pkg);
	return packageDB[pkg]?.essential;
}

function in_package_lists(pkg)
{
	// Search for a given package in the combined platform/arch package list.
	pkg = canonical_name(pkg);
	return pkg in packageList;
}

function add_package(pkg)
{
	pkg = canonical_name(pkg);
	if (is_installed(pkg)) {
		return true;
	}
	if (! in_package_lists(pkg)) {
		warn(`ERROR: package '${pkg}' is not available on this platform\n`);
		return false;
	}

// TODO collect all of abi_version versioned depends provides conflicts etc...
// TODO check for conflicts and error out
// TODO recursively add all dependencies
	packageDB[pkg] = {
		version:     null,
		new_version: packageList[pkg],
	};
	return true;
}

function remove_package(pkg, due_to)
{
	// pkg    - the package to remove, if possible.
	// due_to - the depending, parent package this is being removed causing
	//          'pkg' to be removed.  Non-null indicates recursive closure.

	pkg = canonical_name(pkg);

	if (is_essential(pkg)) {
		// Don't waste time on things like 'libc'.
		// TODO see if there are others, like 'kernel', 'base-files' and such...
		if (due_to == null) {
			// User specified this explicitly, so tell them.
			log(0, `ERROR: package '${pkg}' cannot be removed because it is essential\n`);
		}
		return false; 
	}

	if (due_to != null && is_default(pkg)) {
		log(0, `WARNING: dependency '${pkg}' will not be removed, you must do so explicitly\n`);
		return false;
	}

	if (! is_installed(pkg)) {
		let msg = `WARNING: package '${pkg}' cannot be removed because it is not installed`;
		if (! in_package_lists(pkg)) {
			msg += ".  Did you misspell the package name?";
		}
		log(0, msg + "\n");
		return false;
	}

	let refs = what_depends(pkg);
	log(2, sprintf("INFO: '%s' refs = %s\n", pkg, substr(refs + "", 0, 50)));
	if (due_to in refs && length(refs) == 1) {
		// Must be the only thing in refs, otherwise we can't remove it.
		refs = filter(refs, function(p) { return p != due_to; });
	}
	if (length(refs) > 0) {
		if (due_to == null)
			log(0, `ERROR: '${pkg}' cannot be removed due to ${length(refs)} dependents\n`);
		else
			log(2, sprintf("INFO: '%s' can't be removed, used by '%s'\n", pkg, substr(refs + "", 0, 50)));
		return false;
	}

	let deps = depends_what(pkg);  // The packages that should also be removed.
	for (let dep in deps) {
		// Dependencies are already in canonical form, but may be an
		// alias for some variant.  'dnsmasq' might be satisfied by any
		// of dnsmasq, dnsmasq-full or dnsmasq-dhcpv6.
		dep = what_provides(dep, true);
		if (is_essential(dep)) continue;

		log(2, sprintf("INFO: attempt to remove '%s' dependency '%s'\n", pkg, dep));
		remove_package(dep, pkg);
	}

	log(1, sprintf("INFO: '%s' removed %s\n", pkg, due_to ? `due to '${due_to}'` : "by user"));

	delete packageDB[pkg];  // NO this is completely wrong, just set to-ver to null or something...
	return true;
}

function replace_package(pkg)
{
}

//------------------------------------------------------------------------------

function apply_pkg_mods()
{
	// package_changes - see check_replacements in pkg_scan
	// --add    - verify in available
	// --remove - verify in installed
	//
	// package_changes = [
	//   {
	//     source:    "name-from",  // Required string - name of package in target version
	//     target:    "name-to",    // Optional string - if present, name of replaced package in installed version
	//     revision:  123,          // Required int - revision at which package change was introduced
	//     mandatory: false,        // Optional bool - if true, then package required in target version
	//   },
	//   ...
	// ];
	let errors      = 0;
	let overview    = dl_overview();
	package_changes = overview.branches[release.branch]?.package_changes;

	let rev_num = build.to.rev_num();
	for (let chg in package_changes) {
		if (chg.revision <= rev_num) {
			if (chg.mandatory) {
				if (! is_installed(chg.source)) {
					if (! add_package(chg.src)) {
						errors++;
					}
				}
			}
			else if (chg.target) {
				// replace chg.target with chg.source
			}
		}
	}

	// Do removals first, so any conflicts are suppressed.
	for (let pkg in split(options.remove, ",")) {
		if (! remove_package(pkg)) {
			errors++;
		}
	}
	for (let pkg in split(options.add, ",")) {
		if (! add_package(pkg)) {
			errors++;
		}
	}
	
	return errors == 0;
}

function collect_packages()
{
	// When we move to Alpine apk, see
	//   https://wiki.alpinelinux.org/wiki/Apk_spec
	//
	// Using data from opkg status, build an object containing all installed
	// package dependencies.
	//
	//     packageDB = {
	//         "pkg1": {
	//             abi_version: "2023",
	//             versioned:   "package-name2023",
	//             version:     "version-string",
	//             new_version: "version-string",
	//             essential:   boolean,
	//             depends:     [ "deps", ... ],
	//             provides:    [ "prvs", ... ],
	//             conflicts:   [ "cons", ... ]
	// candidates?
	// default: false, missing: false, keep?: true, more???
	//
	//         },
	//         "pkg2": {
	//             ...
	//         },
	//     };
	//
	// such that
	//     pkg = an installed package
	//     dep = all dependencies; actual 'pkg' name, see NOTE
	//     prv = alternate names for this package
	//     con = packages conflicting with this one
	//
	// NOTE: We process the dependency list to contain only canonical 'pkg'
	// names, by scanning the 'provides' lists and replacing aliases.
	//
	// It appears that the 'conflicts' are not in canonical form, but we
	// can't pre-process them because
	//   vim-full conflicts vim, provided by vim-full but we want vim
	// but
	//   opkg -A info libustream-mbedtls20201210
	// shows non-canonical conflicts values
	// This is because some packages, like vim or dnsmasq, have variant
	// packaging where the base package defines the capability.  For things
	// like libustream-xxx, there is no base capability, just higher-level
	// packages built to depend on the specific conflicting variants.
	// See 'opkg -A info libustream-mbedtls20201210' for an example.
	//
	// Then there are weird non-conflicting packages, like tc-tiny, tc-full
	// and tc-bpf, which all purport to provide 'tc', but don't list conflicts.

	let line;
	let pkg  = null;
	let save = false;
	let data = null;
	let list = null;
	let m    = null;

	let opkg_status = fs.open("/usr/lib/opkg/status", "r");
	while (line = opkg_status.read("line")) {
		line = trim(line);

		if (m = match(line, /^Package: (.*)$/)) {
			if (save && pkg && data) {
				// 'pkg' is NOT ABI-versioned here.
				packageDB[pkg] = data;
			}
			pkg  = m[1]; // Could be ABI-versioned at this point.
			save = true;
			data = {};
		}
		else if (m = match(line, /^ABIVersion: (.*)$/)) {
			// Remove ABI version, see
			//    https://github.com/openwrt/rpcd/blob/master/sys.c#L231
			let ver = m[1];

			data.abi_version = ver;
			data.versioned   = pkg;
			pkg = substr(pkg, 0, -length(ver)); // Only after saving original in 'versioned'.
		}
		else if (match(line, /^Status:.*not-installed/)) {
			save = false;
		}
		else if (m = match(line, /^Depends: (.*)/)) {
			list = replace(m[1], /,|\([^\)]*\)/g, ""); // Remove version specs and commas.
			data.depends = split(trim(list), / +/);
		}
		else if (m = match(line, /^Provides: (.*)/)) {
			list = replace(m[1], /,|\([^\)]*\)/g, "");
			data.provides = split(trim(list), / +/);
		}
		else if (m = match(line, /^Conflicts: (.*)/)) {
			list = replace(m[1], /,|\([^\)]*\)/g, "");
			data.conflicts = split(trim(list), / +/);
		}
		else if (m = match(line, /^Version: (.*)/)) {
			data.version = m[1];
		}
		else if (m = match(line, /^Essential: (.*)/)) {
			data.essential = m[1] == "yes";
		}
	}
	opkg_status.close();

	packageDB["kernel"].essential = true;  // Why isn't it already marked?

	if (save && pkg && data) {
		packageDB[pkg] = data;
	}

	// Once fully populated, we can fix up depend lists to contain only the
	// canonical package names.
	for (let pkg, data in packageDB) {
		data.depends = map(data.depends, canonical_name);
		if (data?.conflicts)
			data.conflicts = map(data.conflicts, canonical_name);

		if (pkg in data.provides) {
			// Remove self from provides list.
			let loc = index(data.provides, pkg);
			splice(data.provides, loc, 1);
			if (length(data.provides) == 0) {
				delete data.provides;
			}
		}
	}

	packageList = dl_package_versions();
	for (let pkg, ver in packageList) {
		pkg = canonical_name(pkg);
		if (pkg in packageDB) {
			packageDB[pkg].new_version = ver;
		}
	}

	if (! apply_pkg_mods()) {
		warn(`Errors collecting package data, terminating...\n`);
		_exit(1);
	}

	packageDB = sort(packageDB);
}

function changed_defaults()
{
	// THESE MUST BE ADDED TO THE BUILD LIST...
	// If we're using "diff_packages: false" in the build blob (which seems
	// proper, given missing/changed underneath stuff).

	for (let pkg in packages.default) {
		if (what_provides(pkg)) {
			printf("default is goofy %-15s %s\n", pkg, what_provides(pkg)); // TODO
		}
	}
	return filter(
		map(packages.default, function(pkg) { return what_provides(pkg); }),
		length
	);
}

function missing_defaults()
{
	// Return the list of default packages that are not currently installed.
	return filter(packages.default, function(pkg) {
		return ! (what_provides(pkg, true) in packageDB);
	});
}

const SrcType = {
	ALL:          0,
	USER_ONLY:    1,
	DEFAULT_ONLY: 2,
};

function top_level(src_type)
{
	// Return only the installed top level packages, i.e., those upon which
	// no other package depends.  'src_type' specifies how the top-level list
	// is to be filtered.
	//
	// Note that this returns installed packages that replace the default
	// packages, for example, 'dnsmasq-full' instead 'dnsmasq'.  This is
	// because 'packages.default' contains non-canonical names.<WAIT this is wrong, canonical names are non-ABI-versioned, not the "what provides" names

	let tl;
	switch (src_type) {
		case SrcType.ALL:
			tl = function(pkg) {
				return what_depends(pkg) == null;
			};
			break;

		case SrcType.DEFAULT_ONLY:
			tl = function(pkg) {
				if (what_depends(pkg)) return false;
				return is_default(pkg);
			};
			break;

		case SrcType.USER_ONLY:
			tl = function(pkg) {
				if (what_depends(pkg)) return false;
				return ! is_default(pkg);
			};
			break;
	}
	return filter(keys(packageDB), tl);
}

function replaced(packages)
{
	// Return a list of packages from the defaults that have replacements
	// in the given list of 'packages'.

	let rep = [];
	for (let pkg in packages) {
		for (let w in provides_what(pkg)) {
			if (is_default(w)) {
				push(rep, w);
			}
		}
	}
	return rep;
}

//------------------------------------------------------------------------------

function initialize_urls()
{
	let sysupgrade = uci.get_first("attendedsysupgrade", "server", "url") ?? "https://sysupgrade.openwrt.org";
	let fs_root    = "https://firmware-selector.openwrt.org";

	let api        = sysupgrade + "/api/v1";
	let build      = api + "/build";
	let status     = build + "/<hash>";
	let static     = sysupgrade + "/json/v1";
	let store      = sysupgrade + "/store";
	let overview   = static + "/overview.json";
	let fs_conf     = fs_root + "/config.js";

	// This should really should be in config somewhere:
	let downloads  = "https://downloads.openwrt.org";

	url = {
		sysupgrade_root: sysupgrade, // sysupgrade server base url
		api_root:        api,        // api for builds and other dynamic requests
		build:           build,      // build request
		build_status:    status,     // build status, same as build appended with hash
		static_root:     static,     // json static api root url
		store_root:      store,      // api database directory for build results
		platform:        null,       // release platform json
		overview:        overview,   // Top-level overview.json, contains available versions
		pkg_arch:        null,       // Generic arch package list, containing most of the items
		pkg_plat:        null,       // Platform packages, built specifically for this platform

		fs_root:         fs_root,    // Firmware-selector root.
		fs_conf:         fs_conf,    // FS config.js

		downloads_root:  downloads,  // download server base url
		download:        null,       // with directory at which the "to" build can be found
		bom:             null,       // BOM for target build
		failed:          null,       // Failure list html
	};
}

function version_cmp(v1, v2)
{
	// Compare two versions and return cmp value based on their relative
	// ordering.  We want to make sure RCs are before any release, and
	// SNAPSHOTs are after.

	// BUG - lexical, so x.10 < x.2, blarg...

	v1 = replace(v1, '-SNAP', '.99')+'~';  // ~ = chr(126), so late in sort order.
	v2 = replace(v2, '-SNAP', '.99')+'~';
	if (v1 < v2) return -1;
	if (v1 > v2) return  1;
	return 0;
}

function version_older(new_version, base_version)
{
	// Use version_cmp to see if new_version < base_version.  Useful to detect
	// if the user is attempting to downgrade their installation.
	//
	//  version_older('23.05.2', 'SNAPSHOT') -> true

	return version_cmp(new_version, base_version) < 0;
}

function show_versions(check_version_to)
{
	// Grab the ASU overview to get all the available versions, scan that
	// for version-to and report.

	let versions;
	if (false) {
		// Actually, let's ignore ASU server and get the metadata from
		// the firmware selector, as it keeps a much bigger and more
		// current list.
		let conf   = dl_fs_conf();
		let latest = conf.default_version;
		versions   = keys(conf.versions);
		push(versions, ...[ "22.03-SNAPSHOT", "23.05-SNAPSHOT"]);
		printf("Available 'version-to' values from %s:\n  ", url.fs_conf);
	}
	else {
		// This is more appropriate, in that it drops the still-available
		// but out-of-support versions.
		let overview = dl_overview();
		let latest   = overview.latest;
		let branches = overview.branches;

		versions = [];
		for (let branch, data in branches) {
			push(versions, ...data.versions);
		}
		printf("Available 'version-to' values from %s:\n  ", url.overview);
	}

	versions = sort(versions, version_cmp);
	print(join("\n  ", versions), "\n");

	if (check_version_to) {
		let version = build.to.version;
		if (version in versions)
			printf("\nYour version-to '%s' appears valid, so either:\n" +
			       "  1) This build has been removed from the server, or\n" +
			       "  2) The ASU server is having issues.\n", version);
		else
			printf("\nYour specified version-to '%s' is invalid.  " +
			       "Pick one from above.\n", version);
	}
}

//------------------------------------------------------------------------------

const BuildInfo = {
	is_snapshot: function() {
		return this.version == "SNAPSHOT";
	},

	is_rel_snapshot: function() {
		return match(this.version, /.*-SNAPSHOT/) != null;
	},

	is_downgrade_from: function(from) {
		if (version_older(this.version, from.version))
			return true;
		// Same or newer version, so check revision number.
		return this.rev_num() < from.rev_num();
	},

	rev_num: function() {
		// Extracts the revision number from the revision code:
		//     "r23630-842932a63d" -> 23630
		let m = match(this.rev_code, /r(\d*)-(.*)/);
		return m ? int(m[1]) : 0;
	},
};

function collect_device_info()
{
	let sysb = ubus.call("system", "board");

	let target   = sysb.release.target;
	let platform = sysb.board_name;
	let ver_from = sysb.release.version;
	let sutype; // Sysupgrade type: combined, combined-efi, sdcard or sysupgrade
	let fstype   = options.fstype ? options.fstype : sysb.rootfs_type;

	let ver_to;
	if (options.version)
		ver_to = options.version;
	else if (ver_from == "SNAPSHOT")
		ver_to = ver_from;
	else {
		let conf = dl_fs_conf();
		ver_to = conf.default_version;
	}

	// BUG sutype = "sdcard" for ??????????
	// See also, auc.c:1657 'select_image' for changing installed fstype to requested one.
	// Wait, is there also "factory"??? See asu/build.py abt line 246
	if (match(target, /x86\//)) {  // This might be wrong, what about x86/geode - geos?
		platform = "generic";
		sutype   = "combined";
	}
	else {
		platform = replace(platform, /,/, "_");
		sutype   = "sysupgrade";
	}

	if (fs.access("/sys/firmware/efi")) {
		// All x86, maybe new armsr, too.
		sutype = `${sutype}-efi`;
	}

	// Fix character case of "snapshot" or "-rc" versions.
	ver_to = uc(ver_to);
	if (index(ver_to, "RC") > 0)
		ver_to = lc(ver_to);

	build = {
		from: proto({
			version:    ver_from,               // Full version name currently installed: "SNAPSHOT" or "22.03.1"
			rev_code:   sysb.release.revision,  // Kernel version that is currently running
			kver:       sysb.kernel,            // Current build on device
		}, BuildInfo),

		to: proto({
			version:    ver_to,                 // Full version name of target: "22.03.0-rc4", "23.05.2" or "SNAPSHOT"
			rev_code:   null,                   // Build number from target
			kver:       null,                   // Kernel version of target build, extracted from BOM
			fstype:     fstype,                 // Requested root FS type
			img_prefix: null,                   // Prefix of image being built
			img_file:   null,                   // Full image name to download and install
			date:       null,                   // Build date of target
		}, BuildInfo),
	};

	device = {
		arch:     null,                   // "x86_64" or "mipsel_24kc"   or "aarch64_cortex-a53", contained in tmp.platform_json
		target:   sysb.release.target,    // "x86/64" or "ath79/generic" or "mediatek/mt7622", from board file
		platform: platform,               // "generic" (for x86) or "tplink,archer-c7-v4" or "linksys,e8450-ubi"
		fstype:   sysb.rootfs_type,       // "ext4" or "squashfs"
		sutype:   sutype,                 // Sysupgrade type, combined, combined-efi or sysupgrade or ???
	};
}

function collect_all()
{
	collect_device_info();

	let rel_dir;
	let rel_branch;
	if (build.to.is_snapshot()) {
		rel_dir    = "snapshots";
		rel_branch = "SNAPSHOT";
	}
	else {
		rel_dir    = `releases/${build.to.version}`;
		rel_branch = replace(build.to.version, /\.[^.]*$/, "");
	}

	release = {
		branch: rel_branch,  // Release branch name: "SNAPSHOT" or "21.07" or "23.05"
		dir:    rel_dir,     // ASU and DL server release branch directory: "snapshots" or "release/23.05.0"
	};

	// We now know enough to finish up the first URL, which will give us the
	// keys to the rest of them.
	url.platform = `${url.static_root}/${release.dir}/targets/${device.target}/${device.platform}.json`;
	let board_json = dl_board();
	if (! board_json) {
		show_versions(true);
		_exit(1);
	}

	device.arch         = board_json.arch_packages;
	build.to.date       = board_json.build_at;
	build.to.rev_code   = board_json.version_code;
	build.to.img_prefix = board_json.image_prefix;

	let location = build.to.is_snapshot()
		     ? "snapshots/faillogs"
		     : `releases/faillogs-${release.branch}`;
	url.failed   = `${url.downloads_root}/${location}/${device.arch}/packages/`;

	url.pkg_arch = `${url.static_root}/${release.dir}/packages/${device.arch}-index.json`;
	url.pkg_plat = `${url.static_root}/${release.dir}/targets/${device.target}/index.json`;

	let prefix   = "openwrt-";
	let starget  = replace(device.target, /\//, "-");
	if (! build.to.is_snapshot())    prefix = `${prefix}${build.to.version}-`;
	if (build.to.is_rel_snapshot())  prefix = lc(`${prefix}${build.to.rev_code}-`);

	url.download = `${url.downloads_root}/${release.dir}/targets/${device.target}`;
	url.bom      = `${url.download}/${prefix}${starget}.bom.cdx.json`;

	let ver = "unknown";
	let bom = dl_bom();
	for (let comp in bom && bom.components) {
		if (comp.name == "kernel") {
			ver = comp.version;
			break;
		}
	}
	build.to.kver = ver;

	for (let img in board_json.images) {
		if (img.type == device.sutype && img.filesystem == build.to.fstype) {
			build.to.img_file = img.name;
			break;
		}
	}

	// These lists need a lot more structure, "sver:...", "tver:...",
	// "default:true", "missing:false" and that sort of thing.
	packages.default = ["kernel"];
	for (let pkg in board_json.default_packages) {
		push(packages.default, pkg);
	}
	for (let pkg in board_json.device_packages) {
		push(packages.default, pkg);
	}
	packages.default = sort(packages.default);

	let installed = ubus.call("rpc-sys", "packagelist", { "all": true });
	packages.installed = sort(installed.packages);

	collect_packages();
}

//------------------------------------------------------------------------------

function dump()
{
	// Send forth a json representation of all the stuff we've collected.
	printf('{\n');
	printf('"options": %.4J,\n', options);
	printf('"url": %.4J,\n', sort(url));
	printf('"tmp": %.4J,\n', sort(tmp));
	printf('"build": %.4J,\n', build);
	printf('"device": %.4J,\n', device);
	printf('"release": %.4J,\n', release);
	if (options.verbosity > 0) {
		printf('"packages": %.4J,\n', packages);
		printf('"packageDB": %.4J,\n', packageDB);
	}
	printf('}\n');
}

function list()
{
	let packages;
	switch (options.format) {
		case "config":
			packages = top_level(SrcType.USER_ONLY);
			let ctype = "y"; // "y" to install, "m" just build package.
			for (let pkg in packages) {
				printf("CONFIG_PACKAGE_%s=%s\n", pkg, ctype);
			}
			break;

		case "fs-all":
			packages = top_level(SrcType.ALL);
			printf("%s\n", join(" ", packages));
			break;

		case "fs-user":
		default:
			packages = top_level(SrcType.USER_ONLY);
			push(packages, ...map(replaced(packages), function(x) { return "-"+x }));
			printf("%s\n", join(" ", packages));
			break;
	}
}

function show_config()
{
	// Pretty print the major configuration values.
	let downgrade = build.to.is_downgrade_from(build.from) ? colorize(" DOWNGRADE", Color.RED) : "";
	print(
		`Board-name     ${device.platform}\n`
		`Target         ${device.target}\n`
		`Root-FS-type   ${device.fstype}\n`
		`Sys-type       ${device.sutype}\n`
		`Package-arch   ${device.arch}\n`
		`Version-from   ${build.from.version} ${build.from.rev_code} (kernel ${build.from.kver})\n`
		`Version-to     ${build.to.version} ${build.to.rev_code} (kernel ${build.to.kver})${downgrade}\n`
		`Build-FS-type  ${build.to.fstype}\n`
		`Build-at       ${build.to.date}\n`
		`Image-prefix   ${build.to.img_prefix}\n`
		`Image-file     ${build.to.img_file}\n`
		`Image-URL      ${url.download}/${build.to.img_file}\n`
	);
	printf("Installed      %3d packages\n", length(packageDB));
	printf("Top-level      %3d packages\n", length(top_level(SrcType.ALL)));
	printf("Default        %3d packages\n", length(packages.default));
	printf("User-installed %3d packages (top-level only)\n", length(top_level(SrcType.USER_ONLY)));
	print("\n");
}

const ver_bits = regexp('[^a-z0-9]', 'i');
function ver_cmp(old, new)
{
	let v1 = split(lc(old), ver_bits);
	let v2 = split(lc(new), ver_bits);
	for (let i, n1 in v1) {
		let n2 = v2[i];
		if (n1 != n2) {
			if (! isnan(int(n1))) n1 = int(n1);
			if (! isnan(int(n2))) n2 = int(n2);
			if (n1 < n2) return -1;
			if (n1 > n2) return  1;
		}
	}
	return 0;
}

function ver_older(v1, v2)
{
	// Is v1 and older version than v2?
	return ver_cmp(v1, v2) < 0;
}

function check_updates()
{
	let missing = 0;

	printf("Package version changes:\n");
	let w0 = max(...map(keys(packageDB), length));
	let w1 = max(...map(values(packageDB), function(p) { return length(p.version); }));
	let f0 =`  %-${w0}s  %s%-${w1}s %s%s%s\n`;
	let changes = 0, new = '';
	for (let pkg, data in packageDB) {
		if (pkg in [ "kernel", "libc" ]) continue;

		let old = data.version;
		let new = data.new_version;
		if (old == new) continue;

		changes++;
		let c1 = "";
		let c2 = "";
		if (old == null) {
			// This happens when you '--add' a new package.
			c1  = color(Color.YELLOW);
			old = "not-installed";
		}
		if (new == null) {
			missing++;
			c2  = color(Color.RED);
			new = "missing to-version";
		}
		else {
			c2  = color(ver_older(old, new) ? Color.GREEN : Color.YELLOW);
		}
		printf(f0, pkg, c1, old, c2, new, color("reset"));
	}

	if (missing) {
		printf("%d packages missing in target version, %s\n", missing, colorize("DO NOT UPGRADE!", Color.RED));
	}
	if (changes) {
		printf("%d packages are out-of-date.\n", changes);
	}
	else {
		printf("  All packages are up-to-date.\n");
	}
	print("\n");

	return missing == 0;
}

function check_pkg_builds()
{
	// Scraping the failures.html is a total hack.
	// Let me know if you have an API on downloads (or other build site)
	// that can give this info.
	//
	// The lines we're scraping look like:
	//    <tr><td class="n"><a href="gummiboot/">gummiboot</a>/</td><td class="s">-</td><td class="d">Tue Apr 23 07:05:36 2024</td></tr>

	let failed = false;

	let html_blob = dl_failures();
	if (html_blob) {
		printf("There are currently package build failures for %s %s:\n", build.to.version, device.arch);

		let info = regexp(
			'<td class="n"><a href="[^<]*">([^<]*)</a>/</td>' +
			'<td class="s">[^<]*</td>' +
			'<td class="d">([^<]*)</td>',
			'g'
		);
		let fails = match(html_blob, info);
		let w0    = max(...map(fails, function(f) { return length(f[1]); }));

		for (let fail in fails) {
			let pkg  = fail[1];
			let date = fail[2];
			let msg;
			if (is_installed(pkg)) {
				failed = true;
				msg = colorize("ERROR: Package installed locally, DO NOT UPGRADE!", Color.RED);
			}
			else {
				msg = "Package not installed locally";
			}
			printf(`  %-${w0}s  %s - %s\n`, pkg, date, msg);
		}
		if (failed) {
			printf("%s", colorize("NOTE THE ERRORS ABOVE:", Color.RED));
		}
		else {
			printf("%s", colorize("Failures don't affect this device,", Color.GREEN));
		}
		printf(" details at\n  %s\n\n", url.failed);

	}

	return ! failed;
}

function tests()
{
	let all = top_level(SrcType.ALL);
	let def = top_level(SrcType.DEFAULT_ONLY);
	let usr = top_level(SrcType.USER_ONLY);

	print('changed defaults\n  ', join(" ", changed_defaults()), '\n');
	print('missing defaults\n  ', join(" ", missing_defaults()), '\n');
	printf('defaults               %d\n  %s\n', length(packages.default), join(" ", packages.default));
	printf('all          top-level %d\n  %s\n', length(all), join(" ", all));
	printf('default-only top-level %d\n  %s\n', length(def), join(" ", def));
	printf('non-default  top-level %d\n  %s\n', length(usr), join(" ", usr));

print('xxxxxxxxxxxxxxxx def vs def\n');
let i = 0;
for (let pkg in packageDB) {
	let in_def = pkg in packages.default;
	let in_top = pkg in def;
	if (in_def || in_top) {
		i++;
		printf('  %3d %-20s  %-3s  %s\n', i, pkg, in_def ? "def" : "-", in_top ? "top" : "-");
	}
}

	print('\n\n');
	print('Now the odd ones, non-top-level defaults:\n');
	let w = max(...map(packages.default, length));
	let f =`  %-${w}s  %s\n`;
	for (let pkg in packages.default) {
		if (pkg in ["kernel", "libc"]) continue;  // Obvious ones...
		let deps = what_depends(pkg);
		if (deps != null) {
			printf(f, pkg, deps);
		}
	}

	if (false) {
		// Allow checking for conflicts if user changes an installed package.
		for (let pkg, data in packageDB) {
			if (data?.conflicts) {
				printf("Installed %-15s conflicts with %s\n", pkg, data.conflicts);
			}
		}
	}

	if (false) {
		for (let pkg in packages.default) {
			if (! (pkg in packages.depends)) {
				printf("  in def not dep  %s\n", pkg);
			}
		}
		print("\n");
		for (let pkg in packages.depends) {
			if (! (pkg in packages.default)) {
				printf("  in dep not def  %s\n", pkg);
			}
		}
	}

	if (true) {
		// Test a handful of packages;
		for (let pkg in [
			"iptables", "libncurses6", "libncursesw", "libncurses", "libncursesw6",
			"dropbear", "vim", "vim-full", "dnsmasq", "dnsmasq-full",
			"wget", "wget-ssl", "uclient-fetch",
			"bort",
		]) {
			printf("%s\n", pkg);
			print('  depends_what  ', depends_what(pkg), '\n');
			print('  what_depends  ', what_depends(pkg), '\n');
			print('  provides_what ', provides_what(pkg), '\n');
			print('  what_provides ', what_provides(pkg), '\n');
			print('  is_default    ', is_default(pkg), '\n');
			print('  is_installed  ', is_installed(pkg), '\n');
		}
	}

	if (true) {
		print("what-provides in defaults:\n");
		for (let pkg in packages.default) {
			if (what_provides(pkg)) {
				printf("def renamed %s -> %s\n", pkg, what_provides(pkg));
			}
		}
	}
}

function blob(report)
{
	// Exclude default packages unless explicitly listed in 'packages'.  When
	// moving between releases, default packages may be added, deleted or
	// renamed, which can result in bricks if something important is missed.
	//
	// On the other hand, what if we replace a default package, say,
	// 'dnsmasq' with 'dnsmasq-full'?  Then we must use the full top-level
	// list, plus target version defaults, and set this value 'true'.
	//
	// False is the safer option, so that's our default value.
	let contains_defaults = true;

	let build_list = top_level(SrcType.ALL); // should be '! contains_defaults' - but not really...
	for (let pkg in packages.default) {
		let p = what_provides(pkg);
		if (! (p in build_list)) {
// TODO what's going on here?
		}
	}

	let init_script;
	if (options.init_script) {
		let inits_maxlen = 20480;  // See https://sysupgrade.openwrt.org/ui/#model-BuildRequest
		let inits_file   = options.init_script == "-" ? fs.stdin : fs.open(options.init_script);
		if (! inits_file) {
			warn(`ERROR: init script file '${options.init_script}' does not exist\n`);
			return null;
		}
		else {
			init_script = inits_file.read("all");
			inits_file.close();
			if (length(init_script) > inits_maxlen) {
				warn(`ERROR: '${options.init_script}' is over the ${inits_maxlen} byte maximum\n`);
				return null;
			}
		}
	}

	if (build.to.fstype != device.fstype && (options.verbosity > 0 || report)) {
		printf("Build: Change file system type from '%s' to '%s'\n", device.fstype, build.to.fstype);
	}

	let blob = {
		client:        "owut/" + VERSION,
		target:        device.target,
		profile:       device.platform,  // sanitized board name

		version:       build.to.version,
		// version_code:  build.to.rev_code,
		filesystem:    build.to.fstype,

		diff_packages: contains_defaults,
		packages:      build_list,
	};

	if (options.rootfs_size) {
		blob.rootfs_size_mb = options.rootfs_size;
		if (options.verbosity > 0 || report) {
			printf("Build: ROOTFS_PARTSIZE set to %d MB\n", options.rootfs_size);
		}
	}

	if (init_script) {
		blob.defaults = init_script;
		if (options.verbosity > 0 || report) {
			printf("Build: Included init script '%s' (%d bytes) in build request\n", options.init_script, length(init_script));
		}
	}

	return blob;
}

function json_blob()
{
	let b = blob();
	return b ? sprintf("%J", b) : null;
}

function show_blob()
{
	let b = blob();
	if (b) {
		printf("%.4J\n", b);
	}
}

function select_image(images)
{
	for (let image in images) {
		if (image.filesystem == build.to.fstype && image.type == device.sutype) {
			return image;
		}
	}
	return null;
}

function verify_image()
{
	// Verify the image with both the saved sha256sum and by passing it
	// to 'sysupgrade --test'.
	//
	// Failed images will be delete, unless '--keep' is set.

	let image = options.image;

	if (! fs.access(image)) {
		warn(`ERROR: image file '${image}' does not exist\n`);
		return false;
	}

	let info = fs.stat(image);
	printf("Verifying: %s (%d bytes) against %s\n", image, info.size, tmp.firmware_sums);

	let result = sha256.verify();
	if (result?.code == 0) {
		printf("  Saved sha256 matches\n");
	}
	else {
		let file_sha = sha256.sum(image);
		let expected = sha256.saved_sum();
		warn(`  ERROR: sha256 doesn't match:\n`
		     `    calculated '${file_sha}'\n`
		     `    saved      '${expected}'\n`);
		if (! options.keep) {
			fs.unlink(image);
		}
		return false;
	}

	result = sysupgrade(image, ["--test"]);
	if (result?.code == 0) {
		printf("  %s\n", join("\n  ", split(trim(result.stderr), "\n")));
	}
	else {
		warn("ERROR: sysupgrade validation failed:\n");
		if (result.stdout) printf("stdout =\n%s\n", result.stdout);
		if (result.stderr) printf("stderr =\n%s\n", result.stderr);
		if (! options.keep) {
			fs.unlink(image);
		}
		return false;
	}

	printf("Checks complete, image is valid.\n");
	return true;
}

function download()
{
	// Use the json_blob to create a build request, run the request and
	// download the result.
	//
	// On success, return true, otherwise spew all sorts of stuff and
	// return false.
	//
	// To download the built image:
	// https://github.com/openwrt/luci/blob/master/applications/luci-app-attendedsysupgrade/htdocs/luci-static/resources/view/attendedsysupgrade/overview.js#L108

	let blob = json_blob();
	if (! blob) return false;

	let start    = time();
	let response = dl_build(blob);
	printf("\nRequesting build ----------------------\n");

	let hash = response?.request_hash;
	if (hash) {
		printf("Hash:   %s\n", hash);
		url.build_status = `${url.build}/${hash}`;
	}

	let queries = 0;
	while (response) {
		let status = response.status;

		printf("Status: %d\n", status);
		printf("Detail: %s", response.detail);
		switch (response.detail) {
			case "queued":
				printf(" - %d ahead of you", response.queue_position);
				break;
			case "started":
				printf(" - %s", response.imagebuilder_status ?? "setup");
				break;
			default:
				break;
		}
		printf("\n");

		switch (status) {
			case 202: // Build in-progress, check in after 10 seconds.
				sleep(10000);
				queries++;
				printf("\nProgress %3d (%4ds) -----------------------------\n", queries, time()-start);
				response = dl_build_status();
				break;

			case 200: // All done.
				printf("Build completed in %d seconds.\n", time()-start);
				if (options.verbosity > 0) {
					printf("build_at       = %s\n",   response.build_at);
					printf("version_number = %s\n",   response.version_number);
					printf("version_code   = %s\n",   response.version_code);
					printf("rootfs_size_mb = %s\n",   response.request.rootfs_size_mb || "default");
				}
				if (options.verbosity > 1) {
					printf("images = %.4J\n", response.images);
				}
				if (options.verbosity > 2) {
					printf("build_cmd = %.4J\n", response.build_cmd);
					printf("manifest = %.4J\n", response.manifest);
				}
				print("\n");

				let image = select_image(response.images);
				if (! image) {
					warn(`Could not locate an image for ${build.to.fstype} and ${device.sutype}...\n`);
					return false;
				}

				let sha = image.sha256;  // LuCI-ASU uses sha256_unsigned for something...
				let dir = response.bin_dir;
				let bin = `${url.store_root}/${dir}`;
				let img = `${bin}/${image.name}`;
				let dst = options.image;

				printf("Image: %s\n", img);

				let msg = `ERROR: Couldn't download image ${image.name}`;
				let rsp = _request(img, dst, msg);
				if (rsp?.status != 200) {
					// need more output here, if 404 or whatever
					return false;
				}

				let manifest = fs.open(tmp.firmware_man, "w");
				if (manifest) {
					manifest.write(sprintf("%.4J\n", response.manifest));
					manifest.close();
					printf("Manifest: %s\n", tmp.firmware_man);
				}

				sha256.save(sha);

				return verify_image();

			// Everything else is "failure - we're done" cases.
			case 400: // Invalid build request.
			case 422: // Unknown package.
			case 500: // Invalid build request.
			default:  // ???
				if (response.error ) printf("error  =\n%s\n", response.error);
				if (response.stdout) printf("stdout =\n%s\n", response.stdout);
				if (response.stderr) printf("stderr =\n%s\n", response.stderr);
				printf("ERROR: build failed with status %s.\n", status);
				return false;
		}
	}
	return false;
}

function install()
{
	// Run sysupgrade to install the image.
	// Probably need some more options reflected from sysupgrade itself.
	// '-n' = discard config comes to mind first, maybe '-f' = force, too.

	sysupgrade(options.image);
}

//------------------------------------------------------------------------------

if (options.verbosity) {
	arg_defs.show_version();
}

ubus = mod_ubus.connect();
if (! ubus) {
	die(`Unable to connect to ubus: ${mod_ubus.error()}\n`);
}

if (! uloop.init()) {
	die(`Unable to initialize uloop: ${uloop.error()}\n`);
}

initialize_urls();

switch (options.command) {
	case "versions":
		show_versions(false);
		break;

	case "dump":
		collect_all();
		dump();
		break;

	case "list":
		collect_all();
		list();
		break;

	case "check":
		collect_all();
		show_config();
		check_updates();
		check_pkg_builds();
		break;

	case "blob":
		collect_all();
		show_blob();
		break;

	case "download":
	case "upgrade":
		collect_all();
		show_config();
		if (! check_updates()) {
			warn("ERROR: update checks reveal errors, can't proceed\n");
			break;
		}
		if (! check_pkg_builds()) {
			warn("ERROR: package build checks reveal errors, can't proceed\n");
			break;
		}
		if (download() && options.command == "upgrade") {
			install();
		}
		break;
	
	case "install":
		if (verify_image()) {
			install();
		}
		break;

	case "verify":
		verify_image();
		break;

	case "_test":
		collect_all();
		show_config();
		check_updates();
		check_pkg_builds();
		tests();
		break;

	default:
		warn(`'${options.command}' not implemented yet.\n`);
		break;
}

uloop.done();
ubus.disconnect();
_exit();
